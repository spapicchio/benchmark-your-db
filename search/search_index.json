{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#qatch-benchmarking-sql-centric-tasks-with-table-representation-learning-models-on-your-data","title":"QATCH: Benchmarking SQL-centric tasks with Table Representation Learning Models on Your Data","text":"<p>This Python library is the official implementation of QATCH: Benchmarking SQL-centric tasks with Table Representation Learning Models on Your Data to appear in NeurIPS Dataset and Benchmark track 2023.</p>"},{"location":"#overview","title":"\udb40\udc76\udb40\udc75\udb40\udc6d\udb40\udc61\udb40\udc70\udb40\udc7f Overview","text":"<ul> <li>What is QATCH? Query-Aided TRL Checklist (QATCH) is a toolbox to highlight TRL models\u2019 strengths   and weaknesses on prorietary tables for Question Answering (QA) and Semantic Parsing (SP).</li> <li>How does it work? Given a proprietary database as input, it generates a testing checklist for QA and SP.</li> <li>More specifically? A query generation algorithm crafts tests by means of the expressive power of SQL.</li> <li>Ok cool, that's it? To evaluate the model's predictions, we propose 5 new metrics intra and inter tuple.</li> <li>Where is processed the data? The data is processed locally. We do not store any data. If you use the ChatGPT   wrapper the data is processed by OpenAI.</li> </ul> QATCH usage pipeline. <p>QATCH's automatically generates and evaluates test checklists on TRL models based on the three-step process depicted below:</p> <ol> <li> <p>QATCH-Generate. It generates a set of queries tailored to proprietary data. For each query it formulates both the    SQL declaration, its free-text version, and the expected ground truth consisting of table instances.    The SQL declaration expresses the logical complexity of the query and reflects the presence/absence of specific    features peculiar to relational data model such as presence of missing values and duplicate values.</p> </li> <li> <p>TRL Model Predictions. It processes the tests for various TRL models and tasks. The current toolbox version    supports three Table Representation Learning (TRL) models for    QA: TAPAS, TAPEX    and Omnitab.    In addition, two LLMs are implemented for QA and SP ChatGPT 3.5 (need the API key)    and LLama2 (need the HuggingFace token).</p> </li> <li> <p>QATCH-Evaluate. It evaluates the models outputs according to a set of cross-task performance metrics.</p> </li> </ol> <p> </p> QATCH\u2019s metrics are computed between the model output (prediction) and expected  ground-truth results (target). The target is the answer of the NL question \"Show me all the data\" over a table with three tuples and two attributes."},{"location":"#who-should-use-qatch","title":"Who should use QATCH?","text":"<p>QATCH is designed to create \"behavioral testing\" checklist for QA and SP tasks. The checklist is used to understand in which case the models fail when processing proprietary data.</p> <p>In a corporate setting, there are at least three scenarios where a given TRL model needs to be evaluated against proprietary datasets:</p> <ul> <li>Comparison: Compare TRL models fine-tuned on private examples to see which one performs best.</li> <li>Validation: As crafting examples is expensive, verify when the quality meets the requirements.</li> <li>Maintenance: Fine-tuned models need to be re-calibrated to avoid data and conceptual shifting,   continuous evaluation helps the identification of this issue.</li> </ul> <p>But the usage of QATCH it is not limited to the TRL models. Indeed, we propose two scenarios where QATCH can be used with LLMs:</p> <ul> <li>LLM compatibility version: Compare different version of the same LLMs to see the best performing one.</li> <li>Prompt engineering: Analyse the best prompt definition based on the proprietary data.</li> </ul> <p> </p> Use case example of engineer Walter.  With QATCH it is able to create a model ranking on his proprietary data for QA and SP."},{"location":"#license","title":"License","text":"<p>The source code of our project is released, for research purposes only, under the following Common Law License: CC-BY-NC. Citing directly the Creative Commons License website: \"This license allows reusers to distribute, remix, adapt, and build upon the material in any medium or format for noncommercial purposes only, and only so long as attribution is given to the creator.\"</p> <p>Source code can be used by companies without making a profit with QATCH or with any product build upon QATCH. </p>"},{"location":"database_reader/","title":"Step 0: Database Reader","text":""},{"location":"database_reader/#overview","title":"Overview","text":"<p>The database_reader package handles connections with the databases file.</p> <p>It contains two class:</p> <ul> <li>SingleDatabase: Given a dictionary of pandas dataframe, it creates the database folder with the database sqlite file.</li> <li>MultipleDatabases: Given the path where the databases are stored, it automatically creates the connection with the stored file. </li> </ul> <p>If the data is already stored in database sqlite files following this pattern \"db_save_path/db_id/db_id.sqlite\" you can create a connection between the tool and the files with MultipleDatabase class:</p> <pre><code>from qatch.database_reader import MultipleDatabases\n\n# The path to multiple databases\ndb_save_path = 'test_db'\ndatabases = MultipleDatabases(db_save_path)\n</code></pre> <p>Instead, if you want to specify different data you can use the SingleDatabase class  to create the sqlite databases in \"db_save_path/db_id/db_id.sqlite\"</p> <pre><code>from qatch.database_reader import SingleDatabase\nimport pandas as pd\n\n# Create dummy table\ndata = {\n    \"year\": [1896, 1900, 1904, 2004, 2008, 2012],\n    \"city\": [\"athens\", \"paris\", \"st. louis\", \"athens\", \"beijing\", \"london\"]\n}\ntable = pd.DataFrame.from_dict(data)\n\n# define the tables in the database (&lt;table_name&gt; : &lt;table&gt;)\ndb_tables = {'olympic_games': table}\n\n# define where to store the sqlite database\ndb_save_path = 'test_db'\n\n# define the name of the database\ndb_id = 'olympic'\n\n# create database connection\ndb = SingleDatabase(db_path=db_save_path, db_name=db_id, tables=db_tables)\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.MultipleDatabases","title":"<code>MultipleDatabases</code>","text":"<p>Manages multiple SQLite databases, allowing dynamic creation and access to individual databases.</p> <p>Attributes:</p> Name Type Description <code>db_path</code> <code>str</code> <p>The base path where the database files are stored.</p> <code>db_ids2db</code> <code>dict</code> <p>A dictionary where the key is the database name, and the value is the SingleDatabase object.</p> <code>_max_db_in_memory</code> <code>int</code> <p>The maximum number of databases to keep in memory. Default is 15.</p> Source code in <code>qatch/database_reader/multiple_databases.py</code> <pre><code>class MultipleDatabases:\n    \"\"\"Manages multiple SQLite databases, allowing dynamic creation and access to individual databases.\n\n    Attributes:\n        db_path (str): The base path where the database files are stored.\n        db_ids2db (dict): A dictionary where the key is the database name, and the value is the SingleDatabase object.\n        _max_db_in_memory (int): The maximum number of databases to keep in memory. Default is 15.\n    \"\"\"\n\n    def __init__(self, db_path: str, _max_db_in_memory=15):\n        \"\"\"Initializes the MultipleDatabases object.\n\n        Args:\n            db_path (str): The base path where the database files will be stored.\n            _max_db_in_memory (int): The maximum number of databases to keep in memory. Default is 15.\n        \"\"\"\n        self.db_path = db_path\n        self.db_ids2db: dict[str, SingleDatabase] = dict()\n        self._max_db_in_memory = _max_db_in_memory\n\n    def get_db_names(self) -&gt; list[str]:\n        \"\"\"Gets the name of the database file from the path.\n\n        Returns:\n            list[str]: A list of database file names.\n        \"\"\"\n        return [x for x in os.listdir(self.db_path)]\n\n    def __contains__(self, other: str) -&gt; bool:\n        \"\"\"Checks if a database with the given name exists in the managed databases.\n\n        Args:\n            other (str): The name of the database to check.\n\n        Returns:\n            bool: True if the database exists, False otherwise.\n        \"\"\"\n        return any(other in db_id for db_id in self.db_ids2db)\n\n    def __getitem__(self, key: str) -&gt; SingleDatabase:\n        \"\"\"Allows accessing a specific database by its name.\n\n        Args:\n            key (str): The name of the database to access.\n\n        Returns:\n            SingleDatabase: The SingleDatabase object corresponding to the given database name.\n        \"\"\"\n        if key not in self.db_ids2db:\n            self.open_db(key)\n        return self.db_ids2db[key]\n\n    def open_db(self, db_id: str):\n        \"\"\"Opens a database with the given name and stores it in memory.\n\n        Args:\n            db_id (str): The name of the database to open.\n        \"\"\"\n        if db_id not in self.db_ids2db:\n            if len(self.db_ids2db) &gt;= self._max_db_in_memory:\n                # FIFO strategy if max reached\n                self.db_ids2db.popitem()\n            self.db_ids2db[db_id] = SingleDatabase(self.db_path, db_name=db_id)\n\n    def get_table(self, db_id: str, tbl_name: str) -&gt; pd.DataFrame:\n        \"\"\"Retrieves a specified table from the database as a Pandas DataFrame.\n\n        Args:\n            db_id (str): The name of the database.\n            tbl_name (str): The name of the table to retrieve from the database.\n\n        Returns:\n            pd.DataFrame: A Pandas DataFrame representing the specified table from the database.\n        \"\"\"\n        return self[db_id].get_table_given(tbl_name)\n\n    def get_schema(self, db_id: str, tbl_name: str) -&gt; pd.DataFrame:\n        \"\"\"Retrieves the schema of a specified table from the database.\n\n        Args:\n            db_id (str): The name of the database.\n            tbl_name (str): The name of the table to retrieve the schema from.\n\n        Returns:\n            pd.DataFrame: A Pandas DataFrame representing the schema of the specified table.\n        \"\"\"\n        return self[db_id].get_schema_given(tbl_name)\n\n    def run_multiple_queries(self, db_id: str, queries: list) -&gt; list[list]:\n        \"\"\"Executes multiple queries on the specified database and returns the results.\n\n          Args:\n              db_id (str): The name of the database to execute the query on.\n              queries (list): The list of SQL queries to be executed on the database.\n\n          Returns:\n              list[list]: A list containing the query results.\n        \"\"\"\n        db = self[db_id]\n        queries_result = map(db.run_query, queries)\n        queries_result = list(map(lambda x: [list(item) for item in x], queries_result))\n        return queries_result\n\n    def run_query(self, db_id: str, query: str) -&gt; list | None:\n        \"\"\"Executes an SQL query on the specified database and returns the results.\n\n        Args:\n            db_id (str): The name of the database to execute the query on.\n            query (str): The SQL query to be executed on the database.\n\n        Returns:\n            list | None: A list containing the query results.\n        \"\"\"\n        ans_query = self[db_id].run_query(query)\n        return [list(x) for x in ans_query]\n\n    def close(self):\n        \"\"\"Closes all the opened databases and clears the memory.\"\"\"\n        [db.close_connection() for db in self.db_ids2db.values()]\n        self.db_ids2db = dict()\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.MultipleDatabases.__contains__","title":"<code>__contains__(other)</code>","text":"<p>Checks if a database with the given name exists in the managed databases.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>str</code> <p>The name of the database to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the database exists, False otherwise.</p> Source code in <code>qatch/database_reader/multiple_databases.py</code> <pre><code>def __contains__(self, other: str) -&gt; bool:\n    \"\"\"Checks if a database with the given name exists in the managed databases.\n\n    Args:\n        other (str): The name of the database to check.\n\n    Returns:\n        bool: True if the database exists, False otherwise.\n    \"\"\"\n    return any(other in db_id for db_id in self.db_ids2db)\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.MultipleDatabases.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Allows accessing a specific database by its name.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the database to access.</p> required <p>Returns:</p> Name Type Description <code>SingleDatabase</code> <code>SingleDatabase</code> <p>The SingleDatabase object corresponding to the given database name.</p> Source code in <code>qatch/database_reader/multiple_databases.py</code> <pre><code>def __getitem__(self, key: str) -&gt; SingleDatabase:\n    \"\"\"Allows accessing a specific database by its name.\n\n    Args:\n        key (str): The name of the database to access.\n\n    Returns:\n        SingleDatabase: The SingleDatabase object corresponding to the given database name.\n    \"\"\"\n    if key not in self.db_ids2db:\n        self.open_db(key)\n    return self.db_ids2db[key]\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.MultipleDatabases.__init__","title":"<code>__init__(db_path, _max_db_in_memory=15)</code>","text":"<p>Initializes the MultipleDatabases object.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>str</code> <p>The base path where the database files will be stored.</p> required <code>_max_db_in_memory</code> <code>int</code> <p>The maximum number of databases to keep in memory. Default is 15.</p> <code>15</code> Source code in <code>qatch/database_reader/multiple_databases.py</code> <pre><code>def __init__(self, db_path: str, _max_db_in_memory=15):\n    \"\"\"Initializes the MultipleDatabases object.\n\n    Args:\n        db_path (str): The base path where the database files will be stored.\n        _max_db_in_memory (int): The maximum number of databases to keep in memory. Default is 15.\n    \"\"\"\n    self.db_path = db_path\n    self.db_ids2db: dict[str, SingleDatabase] = dict()\n    self._max_db_in_memory = _max_db_in_memory\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.MultipleDatabases.close","title":"<code>close()</code>","text":"<p>Closes all the opened databases and clears the memory.</p> Source code in <code>qatch/database_reader/multiple_databases.py</code> <pre><code>def close(self):\n    \"\"\"Closes all the opened databases and clears the memory.\"\"\"\n    [db.close_connection() for db in self.db_ids2db.values()]\n    self.db_ids2db = dict()\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.MultipleDatabases.get_db_names","title":"<code>get_db_names()</code>","text":"<p>Gets the name of the database file from the path.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of database file names.</p> Source code in <code>qatch/database_reader/multiple_databases.py</code> <pre><code>def get_db_names(self) -&gt; list[str]:\n    \"\"\"Gets the name of the database file from the path.\n\n    Returns:\n        list[str]: A list of database file names.\n    \"\"\"\n    return [x for x in os.listdir(self.db_path)]\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.MultipleDatabases.get_schema","title":"<code>get_schema(db_id, tbl_name)</code>","text":"<p>Retrieves the schema of a specified table from the database.</p> <p>Parameters:</p> Name Type Description Default <code>db_id</code> <code>str</code> <p>The name of the database.</p> required <code>tbl_name</code> <code>str</code> <p>The name of the table to retrieve the schema from.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A Pandas DataFrame representing the schema of the specified table.</p> Source code in <code>qatch/database_reader/multiple_databases.py</code> <pre><code>def get_schema(self, db_id: str, tbl_name: str) -&gt; pd.DataFrame:\n    \"\"\"Retrieves the schema of a specified table from the database.\n\n    Args:\n        db_id (str): The name of the database.\n        tbl_name (str): The name of the table to retrieve the schema from.\n\n    Returns:\n        pd.DataFrame: A Pandas DataFrame representing the schema of the specified table.\n    \"\"\"\n    return self[db_id].get_schema_given(tbl_name)\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.MultipleDatabases.get_table","title":"<code>get_table(db_id, tbl_name)</code>","text":"<p>Retrieves a specified table from the database as a Pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>db_id</code> <code>str</code> <p>The name of the database.</p> required <code>tbl_name</code> <code>str</code> <p>The name of the table to retrieve from the database.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A Pandas DataFrame representing the specified table from the database.</p> Source code in <code>qatch/database_reader/multiple_databases.py</code> <pre><code>def get_table(self, db_id: str, tbl_name: str) -&gt; pd.DataFrame:\n    \"\"\"Retrieves a specified table from the database as a Pandas DataFrame.\n\n    Args:\n        db_id (str): The name of the database.\n        tbl_name (str): The name of the table to retrieve from the database.\n\n    Returns:\n        pd.DataFrame: A Pandas DataFrame representing the specified table from the database.\n    \"\"\"\n    return self[db_id].get_table_given(tbl_name)\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.MultipleDatabases.open_db","title":"<code>open_db(db_id)</code>","text":"<p>Opens a database with the given name and stores it in memory.</p> <p>Parameters:</p> Name Type Description Default <code>db_id</code> <code>str</code> <p>The name of the database to open.</p> required Source code in <code>qatch/database_reader/multiple_databases.py</code> <pre><code>def open_db(self, db_id: str):\n    \"\"\"Opens a database with the given name and stores it in memory.\n\n    Args:\n        db_id (str): The name of the database to open.\n    \"\"\"\n    if db_id not in self.db_ids2db:\n        if len(self.db_ids2db) &gt;= self._max_db_in_memory:\n            # FIFO strategy if max reached\n            self.db_ids2db.popitem()\n        self.db_ids2db[db_id] = SingleDatabase(self.db_path, db_name=db_id)\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.MultipleDatabases.run_multiple_queries","title":"<code>run_multiple_queries(db_id, queries)</code>","text":"<p>Executes multiple queries on the specified database and returns the results.</p> <p>Parameters:</p> Name Type Description Default <code>db_id</code> <code>str</code> <p>The name of the database to execute the query on.</p> required <code>queries</code> <code>list</code> <p>The list of SQL queries to be executed on the database.</p> required <p>Returns:</p> Type Description <code>list[list]</code> <p>list[list]: A list containing the query results.</p> Source code in <code>qatch/database_reader/multiple_databases.py</code> <pre><code>def run_multiple_queries(self, db_id: str, queries: list) -&gt; list[list]:\n    \"\"\"Executes multiple queries on the specified database and returns the results.\n\n      Args:\n          db_id (str): The name of the database to execute the query on.\n          queries (list): The list of SQL queries to be executed on the database.\n\n      Returns:\n          list[list]: A list containing the query results.\n    \"\"\"\n    db = self[db_id]\n    queries_result = map(db.run_query, queries)\n    queries_result = list(map(lambda x: [list(item) for item in x], queries_result))\n    return queries_result\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.MultipleDatabases.run_query","title":"<code>run_query(db_id, query)</code>","text":"<p>Executes an SQL query on the specified database and returns the results.</p> <p>Parameters:</p> Name Type Description Default <code>db_id</code> <code>str</code> <p>The name of the database to execute the query on.</p> required <code>query</code> <code>str</code> <p>The SQL query to be executed on the database.</p> required <p>Returns:</p> Type Description <code>list | None</code> <p>list | None: A list containing the query results.</p> Source code in <code>qatch/database_reader/multiple_databases.py</code> <pre><code>def run_query(self, db_id: str, query: str) -&gt; list | None:\n    \"\"\"Executes an SQL query on the specified database and returns the results.\n\n    Args:\n        db_id (str): The name of the database to execute the query on.\n        query (str): The SQL query to be executed on the database.\n\n    Returns:\n        list | None: A list containing the query results.\n    \"\"\"\n    ans_query = self[db_id].run_query(query)\n    return [list(x) for x in ans_query]\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.SingleDatabase","title":"<code>SingleDatabase</code>","text":"<p>Provides a simplified interface for interacting with SQLite databases in Python.</p> <p>Attributes:</p> Name Type Description <code>conn</code> <code>Connection</code> <p>A connection object representing the SQLite database.</p> <code>cursor</code> <code>Cursor</code> <p>A cursor object used to execute SQL commands and retrieve results.</p> <code>db_name</code> <code>str</code> <p>The name of the database.</p> <code>table_schemas</code> <code>Dict[str, DataFrame]</code> <p>Table name as key, table schema as value. Table schema is a Pandas DataFrame with columns: cid, name, type, notnull, dflt_value, pk.</p> <code>table_names</code> <code>str</code> <p>The names of the tables in the database.</p> <code>db_path</code> <code>str</code> <p>Path to the folder which contains the SQLite file.</p> <code>db_path_sqlite</code> <code>str</code> <p>Path to the SQLite file.</p> Source code in <code>qatch/database_reader/single_database.py</code> <pre><code>class SingleDatabase:\n    \"\"\"Provides a simplified interface for interacting with SQLite databases in Python.\n\n    Attributes:\n        conn (sqlite3.Connection): A connection object representing the SQLite database.\n        cursor (sqlite3.Cursor): A cursor object used to execute SQL commands and retrieve results.\n        db_name (str): The name of the database.\n        table_schemas (Dict[str, pd.DataFrame]): Table name as key, table schema as value.\n            Table schema is a Pandas DataFrame with columns: cid, name, type, notnull, dflt_value, pk.\n        table_names (str): The names of the tables in the database.\n        db_path (str): Path to the folder which contains the SQLite file.\n        db_path_sqlite (str): Path to the SQLite file.\n    \"\"\"\n\n    def __init__(self, db_path: str, db_name: str, tables: dict[str, pd.DataFrame] | None = None):\n        \"\"\"\n        Initializes a new SingleDatabase object.\n\n        Args:\n            db_path (str): The path where the database file will be stored, or it is already stored.\n            db_name (str): The name of the database file (without the file extension).\n            tables (Optional[Dict[str, pd.DataFrame]]): A dictionary containing table names as keys and corresponding\n                Pandas DataFrames as values. If provided, these tables will be created in the database upon\n                initialization. Default is None.\n\n        Raises:\n            ValueError: If the specified `db_path` does not exist and no tables are provided.\n\n        \"\"\"\n        if db_path == '' or db_path == '.' or db_path == './':\n            db_path = os.getcwd()\n        db_path = os.path.join(db_path, db_name)\n        if not os.path.exists(db_path):\n            os.makedirs(db_path)\n        path_sqlite_file = os.path.join(db_path, f'{db_name}.sqlite')\n        # This creates a connection object that represents the database in case it does not exist\n        conn = sqlite3.connect(path_sqlite_file)\n        conn.text_factory = lambda b: b.decode(errors='ignore')\n        # A cursor is used to execute SQL commands and retrieve results.\n        cursor = conn.cursor()\n        # select all the table names from the database if any\n        cursor.execute('SELECT name from sqlite_master where type= \"table\"')\n        existing_tables = [tbl[0] for tbl in cursor.fetchall()]\n        if len(existing_tables) == 0:\n            if tables is None:\n                # CASE 1: no tables provided and database does not exist\n                # remove the created file\n                conn.close()\n                raise ValueError(f\"Database path does not exist and no tables were provided \"\n                                 f\"to create the new database in the given path:\"\n                                 f\" {path_sqlite_file}\")\n            else:\n                # CASE 2: tables provided and database does not exist\n                logging.info(f\"provided tables are stored in {path_sqlite_file}\")\n                existing_tables = list(tables.keys())\n                self._set_tables_in_db(tables, conn)\n        else:\n            if tables is not None:\n                # CASE 3: database already exists and tables are provided\n                # log warning tables provided but also database already exists\n                logging.warning(\"tables provided but also database already exists, \"\n                                \"tables in the database will be used\")\n        self.db_path_sqlite = path_sqlite_file\n        self.db_path = db_path\n        self.db_name = db_name\n        self.conn = conn\n        self.cursor = cursor\n        self.table_names = existing_tables\n        self.table_schemas = {tbl_name: pd.read_sql_query(f'PRAGMA table_info(\"{tbl_name}\")', self.conn)\n                              for tbl_name in self.table_names}\n\n    @staticmethod\n    def _set_tables_in_db(tables: dict[str, pd.DataFrame] | None, conn: sqlite3.Connection):\n        \"\"\"\n        Sets the tables in the database based on the provided dictionary.\n\n        Args:\n            tables (Optional[Dict[str, pd.DataFrame]]): A dictionary containing table names as keys and corresponding\n                Pandas DataFrames as values.\n            conn (sqlite3.Connection): A connection object representing the SQLite database.\n        \"\"\"\n        for name, table in tables.items():\n            if name == 'table':\n                name = 'my_table'\n            table.to_sql(name, conn, if_exists='replace', index=False)\n\n    def get_table_given(self, table_name: str) -&gt; pd.DataFrame:\n        \"\"\"\n        Retrieves a specified table from the database as a Pandas DataFrame.\n\n        Args:\n            table_name (str): The name of the table to retrieve from the database.\n\n        Returns:\n            pd.DataFrame: A Pandas DataFrame representing the specified table from the database.\n        \"\"\"\n        return pd.read_sql_query(f\"SELECT * FROM {table_name}\", self.conn)\n\n    def get_schema_given(self, table_name: str) -&gt; pd.DataFrame:\n        \"\"\"\n        Given the table name, returns the schema of the table.\n        Table schema is a Pandas DataFrame with columns: cid, name, type, notnull, dflt_value, pk.\n\n        Args:\n            table_name (str): The name of the table to retrieve the schema from the database.\n\n        Returns:\n            pd.DataFrame: A Pandas DataFrame representing the schema of the specified table from the database.\n        \"\"\"\n        return self.table_schemas[table_name]\n\n    def run_query(self, query: str) -&gt; list[list]:\n        \"\"\"\n        Run a query on the database and return the result.\n\n        Args:\n            query (str): The SQL query to be executed on the database.\n        Returns:\n            list[list]: A list of lists representing the result of the SQL query.\n        \"\"\"\n        self.cursor.execute(query)\n        return self.cursor.fetchall()\n\n    def close_connection(self):\n        \"\"\"Closes the connection to the database.\"\"\"\n        self.conn.close()\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.SingleDatabase.__init__","title":"<code>__init__(db_path, db_name, tables=None)</code>","text":"<p>Initializes a new SingleDatabase object.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>str</code> <p>The path where the database file will be stored, or it is already stored.</p> required <code>db_name</code> <code>str</code> <p>The name of the database file (without the file extension).</p> required <code>tables</code> <code>Optional[Dict[str, DataFrame]]</code> <p>A dictionary containing table names as keys and corresponding Pandas DataFrames as values. If provided, these tables will be created in the database upon initialization. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified <code>db_path</code> does not exist and no tables are provided.</p> Source code in <code>qatch/database_reader/single_database.py</code> <pre><code>def __init__(self, db_path: str, db_name: str, tables: dict[str, pd.DataFrame] | None = None):\n    \"\"\"\n    Initializes a new SingleDatabase object.\n\n    Args:\n        db_path (str): The path where the database file will be stored, or it is already stored.\n        db_name (str): The name of the database file (without the file extension).\n        tables (Optional[Dict[str, pd.DataFrame]]): A dictionary containing table names as keys and corresponding\n            Pandas DataFrames as values. If provided, these tables will be created in the database upon\n            initialization. Default is None.\n\n    Raises:\n        ValueError: If the specified `db_path` does not exist and no tables are provided.\n\n    \"\"\"\n    if db_path == '' or db_path == '.' or db_path == './':\n        db_path = os.getcwd()\n    db_path = os.path.join(db_path, db_name)\n    if not os.path.exists(db_path):\n        os.makedirs(db_path)\n    path_sqlite_file = os.path.join(db_path, f'{db_name}.sqlite')\n    # This creates a connection object that represents the database in case it does not exist\n    conn = sqlite3.connect(path_sqlite_file)\n    conn.text_factory = lambda b: b.decode(errors='ignore')\n    # A cursor is used to execute SQL commands and retrieve results.\n    cursor = conn.cursor()\n    # select all the table names from the database if any\n    cursor.execute('SELECT name from sqlite_master where type= \"table\"')\n    existing_tables = [tbl[0] for tbl in cursor.fetchall()]\n    if len(existing_tables) == 0:\n        if tables is None:\n            # CASE 1: no tables provided and database does not exist\n            # remove the created file\n            conn.close()\n            raise ValueError(f\"Database path does not exist and no tables were provided \"\n                             f\"to create the new database in the given path:\"\n                             f\" {path_sqlite_file}\")\n        else:\n            # CASE 2: tables provided and database does not exist\n            logging.info(f\"provided tables are stored in {path_sqlite_file}\")\n            existing_tables = list(tables.keys())\n            self._set_tables_in_db(tables, conn)\n    else:\n        if tables is not None:\n            # CASE 3: database already exists and tables are provided\n            # log warning tables provided but also database already exists\n            logging.warning(\"tables provided but also database already exists, \"\n                            \"tables in the database will be used\")\n    self.db_path_sqlite = path_sqlite_file\n    self.db_path = db_path\n    self.db_name = db_name\n    self.conn = conn\n    self.cursor = cursor\n    self.table_names = existing_tables\n    self.table_schemas = {tbl_name: pd.read_sql_query(f'PRAGMA table_info(\"{tbl_name}\")', self.conn)\n                          for tbl_name in self.table_names}\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.SingleDatabase.close_connection","title":"<code>close_connection()</code>","text":"<p>Closes the connection to the database.</p> Source code in <code>qatch/database_reader/single_database.py</code> <pre><code>def close_connection(self):\n    \"\"\"Closes the connection to the database.\"\"\"\n    self.conn.close()\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.SingleDatabase.get_schema_given","title":"<code>get_schema_given(table_name)</code>","text":"<p>Given the table name, returns the schema of the table. Table schema is a Pandas DataFrame with columns: cid, name, type, notnull, dflt_value, pk.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table to retrieve the schema from the database.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A Pandas DataFrame representing the schema of the specified table from the database.</p> Source code in <code>qatch/database_reader/single_database.py</code> <pre><code>def get_schema_given(self, table_name: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Given the table name, returns the schema of the table.\n    Table schema is a Pandas DataFrame with columns: cid, name, type, notnull, dflt_value, pk.\n\n    Args:\n        table_name (str): The name of the table to retrieve the schema from the database.\n\n    Returns:\n        pd.DataFrame: A Pandas DataFrame representing the schema of the specified table from the database.\n    \"\"\"\n    return self.table_schemas[table_name]\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.SingleDatabase.get_table_given","title":"<code>get_table_given(table_name)</code>","text":"<p>Retrieves a specified table from the database as a Pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table to retrieve from the database.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A Pandas DataFrame representing the specified table from the database.</p> Source code in <code>qatch/database_reader/single_database.py</code> <pre><code>def get_table_given(self, table_name: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves a specified table from the database as a Pandas DataFrame.\n\n    Args:\n        table_name (str): The name of the table to retrieve from the database.\n\n    Returns:\n        pd.DataFrame: A Pandas DataFrame representing the specified table from the database.\n    \"\"\"\n    return pd.read_sql_query(f\"SELECT * FROM {table_name}\", self.conn)\n</code></pre>"},{"location":"database_reader/#qatch.database_reader.SingleDatabase.run_query","title":"<code>run_query(query)</code>","text":"<p>Run a query on the database and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The SQL query to be executed on the database.</p> required <p>Returns:     list[list]: A list of lists representing the result of the SQL query.</p> Source code in <code>qatch/database_reader/single_database.py</code> <pre><code>def run_query(self, query: str) -&gt; list[list]:\n    \"\"\"\n    Run a query on the database and return the result.\n\n    Args:\n        query (str): The SQL query to be executed on the database.\n    Returns:\n        list[list]: A list of lists representing the result of the SQL query.\n    \"\"\"\n    self.cursor.execute(query)\n    return self.cursor.fetchall()\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>First need to install QATCH. You can do this by running the following command:</p> <pre><code># Using poetry (recommended)\npoetry add QATCH\n\n# Using pip\npip install QATCH \n</code></pre> <p>Since QATCH is intended to be used without the inference step, the base installation does not come with the models' requirements. However, in case you want to use our implementation you can add the extras requirements.</p> <pre><code># Using poetry (recommended)\npoetry add QATCH -E model\n\n# Using pip\npip install QATCH[model] \n</code></pre>"},{"location":"getting_started/#create-connection-with-input-data","title":"Create connection with input data","text":"<p>Once you have installed QATCH, you need to create a connection between your data and the tool. If your data is not stored in a sqlite database you can use our code to generate it. If this is not the case, you can skip this passage.</p> <pre><code>from qatch.database_reader import SingleDatabase\nimport pandas as pd\n\n# Create dummy table\ndata = {\n    \"year\": [1896, 1900, 1904, 2004, 2008, 2012],\n    \"city\": [\"athens\", \"paris\", \"st. louis\", \"athens\", \"beijing\", \"london\"]\n}\ntable = pd.DataFrame.from_dict(data)\n\n# define the tables in the database (&lt;table_name&gt; : &lt;table&gt;)\ndb_tables = {'olympic_games': table}\n\n# define where to store the sqlite database\ndb_save_path = 'test_db'\n\n# define the name of the database\ndb_id = 'olympic'\n\n# create database connection\ndb = SingleDatabase(db_path=db_save_path, db_name=db_id, tables=db_tables)\n</code></pre> <p>This class will create the sqlite database in \"db_save_path/db_id/db_id.sqlite\".</p> <p>Once you have the database stored in this format \"db_save_path/db_id/db_id.sqlite\", you can create a connection in the following way:</p> <pre><code>from qatch.database_reader import MultipleDatabases\n\n# The path to multiple databases\ndb_save_path = 'test_db'\ndatabases = MultipleDatabases(db_save_path)\n</code></pre> <p>This class automatically detects the available databases and handle the communication between the code and the sqlite files.</p>"},{"location":"getting_started/#step-1-qatch-generate","title":"Step 1: QATCH generate","text":"<pre><code>from qatch import TestGenerator\n\n# init generator\ntest_generator = TestGenerator(databases=databases)\n\n# generate tests for each database and for each generator\ntests_df = test_generator.generate()\n</code></pre> <p>Test generator automatically creates a checklist based on the proprietary data. The tests_df dataframe contains:</p> <ul> <li>db_id: The database name associated with the test.</li> <li>tbl_name: The table name associated with the test.</li> <li>sql_tags: the SQL generator used to create the test.</li> <li>query: The generated query. Used to evaluate the model.</li> <li>question: The generated question associated with the query. Used as input for the model.</li> </ul>"},{"location":"getting_started/#step-2-trl-model-predictions","title":"Step 2: TRL model predictions","text":"<p>QATCH is intended to be used without the inference step. However, it supports several models for reproducibility reason.</p> <pre><code>from tqdm import tqdm\n\nfrom qatch.models import Tapas\n\n# init the model \nmodel = Tapas(model_name=\"google/tapas-large-finetuned-wtq\")\n\n# iterate for each row and run prediction\ntqdm.pandas(desc=f'Predicting for {model.name}')\ntests_df[f'predictions_{model.name}'] = tests_df.progress_apply(\n    lambda row: model.predict(\n        table=databases.get_table(db_id=row['db_id'], tbl_name=row['tbl_name']),\n        query=row['question'],\n        tbl_name=row['tbl_name']\n    ),\n    axis=1\n)\n</code></pre> <p>Since Tapas, Tapex, Omnitab and LLama2 are based on huggingFace, the model_name parameter can be any possible name associate with the model in the hub.</p> <p>To use ChatGPT_QA or ChatGPT_SP you need to provide the API credentials:</p> <pre><code>from qatch.models import ChatGPT_QA\n\nmodel = ChatGPT_QA(model_name=\"gpt-3.5-turbo-0613\",\n                   api_key=\"your_api_key_chatgpt\",\n                   api_org=\"your_api_org_chatgpt\")\n</code></pre> <p>To use LLama2_QA or LLama2_SP you need to specify the HuggingFace token</p> <p><pre><code>from qatch.models import LLama2_QA\n\nmodel = LLama2_QA(model_name=\"meta-llama/Llama-2-7b-chat-hf\",\n                  hugging_face_token=\"your_hugging_face_token\")\n</code></pre> The tests_df dataframe after the prediction phase contains:</p> <ul> <li>db_id: The database name associated with the test.</li> <li>tbl_name: The table name associated with the test.</li> <li>sql_tags: the SQL generator used to create the test.</li> <li>query: The generated query. Used to evaluate the model.</li> <li>question: The generated question associated with the query. Used as input for the model.</li> <li>predictions_: The predicted query/cells based on the task (SP or QA respectively)"},{"location":"getting_started/#step-3-qatch-evaluate","title":"Step 3: QATCH evaluate","text":"<p>QATCH MetricEvaluator is composed of 5 metrics (3 intra-tuple and 2 inter-tuple).</p> <p><pre><code>from qatch import MetricEvaluator\n\nevaluator = MetricEvaluator(databases=databases)\ntests_df = evaluator.evaluate_with_df(tests_df,\n                                      prediction_col_name=\"&lt;prediction_col_name&gt;\",\n                                      task=\"QA\")\n</code></pre> The final dataframe contains:</p> <ul> <li>db_id: The database name associated with the test.</li> <li>tbl_name: The table name associated with the test.</li> <li>sql_tags: the SQL generator associated with the test.</li> <li>query: The generated query from step 1.</li> <li>question: The generated question from step 1. Used as input for the model.</li> <li>predictions_: The predicted query/cells from step 2. <li>5 metrics: The metrics used to evaluate the models.</li>"},{"location":"metrics/","title":"Step 3: Metrics","text":""},{"location":"metrics/#qatch.metric_evaluator.MetricEvaluator","title":"<code>MetricEvaluator</code>","text":"<p>Class for evaluating SQL query prediction metrics using target results and predicted outputs.</p> <p>Attributes:</p> Name Type Description <code>databases</code> <code>MultipleDatabases</code> <p>Object representing database connections. This attribute stores information about multiple database connections.</p> <code>metrics</code> <code>list[str]</code> <p>List of metric names to be evaluated. Default metrics include: ['cell_precision', 'cell_recall', 'tuple_cardinality', 'tuple_constraint', 'tuple_order']</p> Source code in <code>qatch/metric_evaluator.py</code> <pre><code>class MetricEvaluator:\n    \"\"\"\n    Class for evaluating SQL query prediction metrics using target results and predicted outputs.\n\n    Attributes:\n        databases (MultipleDatabases): Object representing database connections.\n            This attribute stores information about multiple database connections.\n\n        metrics (list[str]): List of metric names to be evaluated. Default metrics include:\n            ['cell_precision', 'cell_recall', 'tuple_cardinality', 'tuple_constraint', 'tuple_order']\n    \"\"\"\n\n    def __init__(self, databases: MultipleDatabases, metrics: list[str] | str | None = None):\n        \"\"\"\n        initialize the MetricEvaluator object.\n\n        Args:\n            databases (MultipleDatabases): Object representing database connections.\n                This attribute stores information about multiple database connections.\n            metrics (list[str] | str | None): List of metric names to be evaluated. Default metrics include:\n                ['cell_precision', 'cell_recall', 'tuple_cardinality', 'tuple_constraint', 'tuple_order']\n        \"\"\"\n        if metrics is None:\n            metrics = ['cell_precision', 'cell_recall',\n                       'tuple_cardinality', 'tuple_constraint',\n                       'tuple_order']\n\n        self.metrics = metrics if isinstance(metrics, list) else [metrics]\n\n        self._tags_generator = {\n            'cell_precision': CellPrecisionTag,\n            'cell_recall': CellRecallTag,\n            'tuple_cardinality': TupleCardinalityTag,\n            'tuple_constraint': TupleConstraintTag,\n            'tuple_order': TupleOrderTag,\n        }\n        self.databases = databases\n\n    def evaluate_with_df(self, df, prediction_col_name: str, task: str) -&gt; pd.DataFrame:\n        \"\"\"\n        Evaluate the specified metrics using the provided DataFrame containing query results and predictions.\n        The df must contain 'query' and 'db_id' columns, and the \"prediction_col_name\" must be present in the df.\n        For SP task, it generates the prediction results for the queries that are not equal to the target.\n\n        Args:\n            df (pd.DataFrame): The DataFrame containing query results, prediction, and other relevant columns.\n            prediction_col_name (str): The name of the column containing prediction values.\n            task (str): The task type, either 'SP' for SQL prediction or other task types.\n\n        Returns:\n            pd.DataFrame: A DataFrame with added metric columns.\n\n        Examples:\n            Given a DataFrame \"tests_df\" with the following columns: ['query', 'db_id', 'pred_tapas']\n            and a MultipleDatabases object connected with the db_id,\n            &gt;&gt;&gt; evaluator = MetricEvaluator(databases)\n            &gt;&gt;&gt; tests_df = evaluator.evaluate_with_df(tests_df, 'pred_tapas', 'SP')\n            &gt;&gt;&gt; tests_df.columns.tolist()\n            [query, db_id, pred_tapas, cell_precision_pred_tapas, cell_recall_pred_tapas, tuple_cardinality_pred_tapas, tuple_constraint_pred_tapas, tuple_order_pred_tapas]\n        \"\"\"\n        # get target values\n        df, target_col_name = self._get_query_results_from_db(df)\n        if task == 'SP':\n            # get prediction values for the SP task and the new prediction_col_name\n            df, prediction_col_name = self._get_SP_query_results_from_db(df, prediction_col_name)\n\n        # only the test where order is present\n        queries = df['query'].str.lower()\n        mask_order = queries.str.contains('order')\n\n        # create the mask for the EQUAL case (no need to run the evaluation)\n        mask_equal = df[prediction_col_name] == 'EQUAL'\n\n        for metric in self.metrics:\n            generator = self._tags_generator[metric]()\n            # initialize the metric column\n            metric_col_name = f'{metric}_{prediction_col_name}'\n            df.loc[:, metric_col_name] = None\n            if metric == 'tuple_order':\n                # when the target and prediction are equal, the metric is 1\n                df.loc[mask_order &amp; mask_equal, metric] = 1\n                mask = mask_order &amp; ~mask_equal\n            else:\n                # when the target and prediction are equal, the metric is 1\n                df.loc[mask_equal, metric_col_name] = 1\n                mask = ~mask_equal\n\n            # evaluate the metric only for the test where the prediction is not equal to the target\n            tqdm.pandas(desc=f'Evaluating {metric_col_name}')\n            df.loc[mask, metric_col_name] = df[mask].progress_apply(\n                lambda r: generator.evaluate_single_test_metric(r[target_col_name], r[prediction_col_name]),\n                axis=1)\n        # at the end drop the columns that are not needed anymore\n        df = df.drop(columns=[target_col_name, prediction_col_name]) if task == 'SP' \\\n            else df.drop(columns=[target_col_name])\n        return df\n\n    def _get_query_results_from_db(self, df) -&gt; tuple[pd.DataFrame, str]:\n        \"\"\"\n        Retrieve query results for the \"query\" column.\n        Since these queries represent the target values, this function raises an error if the query is not valid.\n\n        Args:\n            df (pd.DataFrame): The input DataFrame containing query information.\n\n        Returns:\n            tuple[pd.DataFrame, str]: A tuple containing the new DataFrame with query results and the column name for query results.\n\n        Raises:\n            sqlite3.OperationalError: If the query is not valid (the target must be correct).\n        \"\"\"\n        query_column = 'query'\n        # group-by the df for each db_id present\n        grouped_by_db_df = df.groupby('db_id').agg(list)\n        # for each db_id get the results of the query from the db\n        tqdm.pandas(desc='Getting target results')\n        grouped_by_db_df[f'{query_column}_result'] = grouped_by_db_df.progress_apply(\n            lambda row: self.databases.run_multiple_queries(row.name, row[query_column]),\n            axis=1\n        )\n        # expand the grouped df\n        columns = grouped_by_db_df.columns.tolist()\n        df = grouped_by_db_df.explode(columns).reset_index()\n        return df, f'{query_column}_result'\n\n    @staticmethod\n    def _create_mask_target_equal_prediction(target: str, prediction: str) -&gt; bool:\n        \"\"\"\n        Create a mask based on whether the target and prediction strings are equal after cleaning.\n\n        Args:\n            target (str): The target string.\n            prediction (str): The prediction string.\n\n        Returns:\n            bool: True if cleaned prediction equals cleaned target, False otherwise.\n        \"\"\"\n        new_target = (target.lower()\n                      .replace(\" ,\", \",\").replace(\"  \", \" \").replace('\"', '').replace(\"'\", '')\n                      .strip())\n\n        new_pred = (prediction.lower()\n                    .replace(\" ,\", \",\").replace(\"  \", \" \").replace('\"', '').replace(\"'\", '')\n                    .replace(' ( ', '(').replace(' )', ')')\n                    .strip())\n        return True if new_pred == new_target else False\n\n    def _get_SP_query_results_from_db(self, df: pd.DataFrame, prediction_col_name: str\n                                      ) -&gt; tuple[pd.DataFrame, str]:\n        \"\"\"\n        Retrieve query results for the \"prediction_col_name\" column.\n        Since this is the prediction of SP model, this function returns None if the query is not valid.\n\n        Args:\n            df (pd.DataFrame): The input DataFrame containing query information.\n            prediction_col_name (str): The name of the column containing prediction values.\n\n        Returns:\n            tuple[pd.DataFrame, str]: A tuple containing the new DataFrame with query results and the column name for query results.\n        \"\"\"\n\n        def wrapper_prediction(db_id, query):\n            \"\"\"in case the prediction return an error, we return None\"\"\"\n            # to avoid multiple queries in the same string error\n            query = query.replace(';', '')\n            try:\n                output = self.databases.run_query(db_id, query)\n            except sqlite3.Error as e:\n                # catch any possible error of prediction and return None\n                logging.error(e)\n                return None\n            else:\n                return output\n\n        mask_equal = df.apply(\n            lambda row: self._create_mask_target_equal_prediction(row['query'],\n                                                                  row[prediction_col_name]),\n            axis=1\n        )\n        # create the new column for the prediction\n        new_prediction_col_name = f'{prediction_col_name}_result'\n        df.loc[mask_equal, new_prediction_col_name] = 'EQUAL'\n        # get prediction values for the elements not equal\n        tqdm.pandas(desc='Getting prediction results for not equal SQL predictions')\n        df.loc[~mask_equal, new_prediction_col_name] = df.loc[~mask_equal].progress_apply(\n            lambda row: wrapper_prediction(row['db_id'], row[prediction_col_name]),\n            axis=1\n        )\n        return df, new_prediction_col_name\n</code></pre>"},{"location":"metrics/#qatch.metric_evaluator.MetricEvaluator.__init__","title":"<code>__init__(databases, metrics=None)</code>","text":"<p>initialize the MetricEvaluator object.</p> <p>Parameters:</p> Name Type Description Default <code>databases</code> <code>MultipleDatabases</code> <p>Object representing database connections. This attribute stores information about multiple database connections.</p> required <code>metrics</code> <code>list[str] | str | None</code> <p>List of metric names to be evaluated. Default metrics include: ['cell_precision', 'cell_recall', 'tuple_cardinality', 'tuple_constraint', 'tuple_order']</p> <code>None</code> Source code in <code>qatch/metric_evaluator.py</code> <pre><code>def __init__(self, databases: MultipleDatabases, metrics: list[str] | str | None = None):\n    \"\"\"\n    initialize the MetricEvaluator object.\n\n    Args:\n        databases (MultipleDatabases): Object representing database connections.\n            This attribute stores information about multiple database connections.\n        metrics (list[str] | str | None): List of metric names to be evaluated. Default metrics include:\n            ['cell_precision', 'cell_recall', 'tuple_cardinality', 'tuple_constraint', 'tuple_order']\n    \"\"\"\n    if metrics is None:\n        metrics = ['cell_precision', 'cell_recall',\n                   'tuple_cardinality', 'tuple_constraint',\n                   'tuple_order']\n\n    self.metrics = metrics if isinstance(metrics, list) else [metrics]\n\n    self._tags_generator = {\n        'cell_precision': CellPrecisionTag,\n        'cell_recall': CellRecallTag,\n        'tuple_cardinality': TupleCardinalityTag,\n        'tuple_constraint': TupleConstraintTag,\n        'tuple_order': TupleOrderTag,\n    }\n    self.databases = databases\n</code></pre>"},{"location":"metrics/#qatch.metric_evaluator.MetricEvaluator.evaluate_with_df","title":"<code>evaluate_with_df(df, prediction_col_name, task)</code>","text":"<p>Evaluate the specified metrics using the provided DataFrame containing query results and predictions. The df must contain 'query' and 'db_id' columns, and the \"prediction_col_name\" must be present in the df. For SP task, it generates the prediction results for the queries that are not equal to the target.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame containing query results, prediction, and other relevant columns.</p> required <code>prediction_col_name</code> <code>str</code> <p>The name of the column containing prediction values.</p> required <code>task</code> <code>str</code> <p>The task type, either 'SP' for SQL prediction or other task types.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame with added metric columns.</p> <p>Examples:</p> <p>Given a DataFrame \"tests_df\" with the following columns: ['query', 'db_id', 'pred_tapas'] and a MultipleDatabases object connected with the db_id,</p> <pre><code>&gt;&gt;&gt; evaluator = MetricEvaluator(databases)\n&gt;&gt;&gt; tests_df = evaluator.evaluate_with_df(tests_df, 'pred_tapas', 'SP')\n&gt;&gt;&gt; tests_df.columns.tolist()\n[query, db_id, pred_tapas, cell_precision_pred_tapas, cell_recall_pred_tapas, tuple_cardinality_pred_tapas, tuple_constraint_pred_tapas, tuple_order_pred_tapas]\n</code></pre> Source code in <code>qatch/metric_evaluator.py</code> <pre><code>def evaluate_with_df(self, df, prediction_col_name: str, task: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Evaluate the specified metrics using the provided DataFrame containing query results and predictions.\n    The df must contain 'query' and 'db_id' columns, and the \"prediction_col_name\" must be present in the df.\n    For SP task, it generates the prediction results for the queries that are not equal to the target.\n\n    Args:\n        df (pd.DataFrame): The DataFrame containing query results, prediction, and other relevant columns.\n        prediction_col_name (str): The name of the column containing prediction values.\n        task (str): The task type, either 'SP' for SQL prediction or other task types.\n\n    Returns:\n        pd.DataFrame: A DataFrame with added metric columns.\n\n    Examples:\n        Given a DataFrame \"tests_df\" with the following columns: ['query', 'db_id', 'pred_tapas']\n        and a MultipleDatabases object connected with the db_id,\n        &gt;&gt;&gt; evaluator = MetricEvaluator(databases)\n        &gt;&gt;&gt; tests_df = evaluator.evaluate_with_df(tests_df, 'pred_tapas', 'SP')\n        &gt;&gt;&gt; tests_df.columns.tolist()\n        [query, db_id, pred_tapas, cell_precision_pred_tapas, cell_recall_pred_tapas, tuple_cardinality_pred_tapas, tuple_constraint_pred_tapas, tuple_order_pred_tapas]\n    \"\"\"\n    # get target values\n    df, target_col_name = self._get_query_results_from_db(df)\n    if task == 'SP':\n        # get prediction values for the SP task and the new prediction_col_name\n        df, prediction_col_name = self._get_SP_query_results_from_db(df, prediction_col_name)\n\n    # only the test where order is present\n    queries = df['query'].str.lower()\n    mask_order = queries.str.contains('order')\n\n    # create the mask for the EQUAL case (no need to run the evaluation)\n    mask_equal = df[prediction_col_name] == 'EQUAL'\n\n    for metric in self.metrics:\n        generator = self._tags_generator[metric]()\n        # initialize the metric column\n        metric_col_name = f'{metric}_{prediction_col_name}'\n        df.loc[:, metric_col_name] = None\n        if metric == 'tuple_order':\n            # when the target and prediction are equal, the metric is 1\n            df.loc[mask_order &amp; mask_equal, metric] = 1\n            mask = mask_order &amp; ~mask_equal\n        else:\n            # when the target and prediction are equal, the metric is 1\n            df.loc[mask_equal, metric_col_name] = 1\n            mask = ~mask_equal\n\n        # evaluate the metric only for the test where the prediction is not equal to the target\n        tqdm.pandas(desc=f'Evaluating {metric_col_name}')\n        df.loc[mask, metric_col_name] = df[mask].progress_apply(\n            lambda r: generator.evaluate_single_test_metric(r[target_col_name], r[prediction_col_name]),\n            axis=1)\n    # at the end drop the columns that are not needed anymore\n    df = df.drop(columns=[target_col_name, prediction_col_name]) if task == 'SP' \\\n        else df.drop(columns=[target_col_name])\n    return df\n</code></pre>"},{"location":"metrics/#qatch.metrics.CellPrecisionTag","title":"<code>CellPrecisionTag</code>","text":"<p>             Bases: <code>AbstractMetric</code></p> Source code in <code>qatch/metrics/cell_precision_tag.py</code> <pre><code>class CellPrecisionTag(AbstractMetric):\n    def evaluate_single_no_special_case(self, target: list[list],\n                                        prediction: list[list]) -&gt; float:\n        \"\"\"\n        Calculates the ratio of predicted cells that are in the target.\n        Does not consider cardinality (measured by other tags).\n        High precision indicates that the model is good at identifying relevant instances\n        and has a low false positive rate.\n\n        Args:\n            target (list[list]): Target table to be compared with the prediction table.\n            prediction (list[list]): Prediction table to be compared with the target table.\n\n        Returns:\n            float: Precision score between [0, 1].\n                - 0 indicates no cell in the prediction is in the target.\n                - 1 indicates all cells in the prediction are in the target.\n\n        Examples:\n            &gt;&gt;&gt; evaluator = CellPrecisionTag()\n            &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n            &gt;&gt;&gt; prediction = [['a', 'b'], ['c', 'd']\n            &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n            1.0\n\n            &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n            &gt;&gt;&gt; prediction = [['a', 'b'], ['c', 'e']\n            &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n            0.75\n\n            &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n            &gt;&gt;&gt; prediction = [['a'], ['b'], ['c'], ['d']]\n            &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n            1.0  # it is one even if the schema does not match (we introduce tuple constraints for this)\n        \"\"\"\n        target = np.array(target)\n        prediction = np.array(prediction)\n\n        sum_cell_match = np.sum(np.isin(prediction, target))\n        return round(sum_cell_match / prediction.size, 3)\n</code></pre>"},{"location":"metrics/#qatch.metrics.CellPrecisionTag.evaluate_single_no_special_case","title":"<code>evaluate_single_no_special_case(target, prediction)</code>","text":"<p>Calculates the ratio of predicted cells that are in the target. Does not consider cardinality (measured by other tags). High precision indicates that the model is good at identifying relevant instances and has a low false positive rate.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>list[list]</code> <p>Target table to be compared with the prediction table.</p> required <code>prediction</code> <code>list[list]</code> <p>Prediction table to be compared with the target table.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Precision score between [0, 1]. - 0 indicates no cell in the prediction is in the target. - 1 indicates all cells in the prediction are in the target.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; evaluator = CellPrecisionTag()\n&gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n&gt;&gt;&gt; prediction = [['a', 'b'], ['c', 'd']\n&gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n1.0\n</code></pre> <pre><code>&gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n&gt;&gt;&gt; prediction = [['a', 'b'], ['c', 'e']\n&gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n0.75\n</code></pre> <pre><code>&gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n&gt;&gt;&gt; prediction = [['a'], ['b'], ['c'], ['d']]\n&gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n1.0  # it is one even if the schema does not match (we introduce tuple constraints for this)\n</code></pre> Source code in <code>qatch/metrics/cell_precision_tag.py</code> <pre><code>def evaluate_single_no_special_case(self, target: list[list],\n                                    prediction: list[list]) -&gt; float:\n    \"\"\"\n    Calculates the ratio of predicted cells that are in the target.\n    Does not consider cardinality (measured by other tags).\n    High precision indicates that the model is good at identifying relevant instances\n    and has a low false positive rate.\n\n    Args:\n        target (list[list]): Target table to be compared with the prediction table.\n        prediction (list[list]): Prediction table to be compared with the target table.\n\n    Returns:\n        float: Precision score between [0, 1].\n            - 0 indicates no cell in the prediction is in the target.\n            - 1 indicates all cells in the prediction are in the target.\n\n    Examples:\n        &gt;&gt;&gt; evaluator = CellPrecisionTag()\n        &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n        &gt;&gt;&gt; prediction = [['a', 'b'], ['c', 'd']\n        &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n        1.0\n\n        &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n        &gt;&gt;&gt; prediction = [['a', 'b'], ['c', 'e']\n        &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n        0.75\n\n        &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n        &gt;&gt;&gt; prediction = [['a'], ['b'], ['c'], ['d']]\n        &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n        1.0  # it is one even if the schema does not match (we introduce tuple constraints for this)\n    \"\"\"\n    target = np.array(target)\n    prediction = np.array(prediction)\n\n    sum_cell_match = np.sum(np.isin(prediction, target))\n    return round(sum_cell_match / prediction.size, 3)\n</code></pre>"},{"location":"metrics/#qatch.metrics.CellRecallTag","title":"<code>CellRecallTag</code>","text":"<p>             Bases: <code>AbstractMetric</code></p> Source code in <code>qatch/metrics/cell_recall_tag.py</code> <pre><code>class CellRecallTag(AbstractMetric):\n    def evaluate_single_no_special_case(self, target: list[list],\n                                        prediction: list[list]) -&gt; float:\n        \"\"\"\n        Calculates the ratio of target cells that are in the prediction.\n        High recall indicates that the model is good at identifying all relevant instances\n        and has a low false negative rate.\n\n        Args:\n            target (list[list]): Target table to be compared with the prediction table.\n            prediction (list[list]): Prediction table to be compared with the target table.\n\n        Returns:\n            float: Recall score between [0, 1].\n                - 0 indicates no cell in the target is in the prediction.\n                - 1 indicates all cells in the target are in the prediction.\n\n        Examples:\n            &gt;&gt;&gt; evaluator = CellRecallTag()\n            &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n            &gt;&gt;&gt; prediction = [['a', 'b'], ['c', 'd']\n            &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n            1.0\n\n            &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n            &gt;&gt;&gt; prediction = [['a', 'x'], ['y', 'd']]\n            &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n            0.5\n\n            &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n            &gt;&gt;&gt; prediction = [['a', 'a'], ['b', 'b'], ['c', 'd']]\n            &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n            1.0\n        \"\"\"\n        target = np.array(target)\n        prediction = np.array(prediction)\n        sum_cell_match = np.sum(np.isin(target, prediction))\n        return round(sum_cell_match / target.size, 3)\n</code></pre>"},{"location":"metrics/#qatch.metrics.CellRecallTag.evaluate_single_no_special_case","title":"<code>evaluate_single_no_special_case(target, prediction)</code>","text":"<p>Calculates the ratio of target cells that are in the prediction. High recall indicates that the model is good at identifying all relevant instances and has a low false negative rate.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>list[list]</code> <p>Target table to be compared with the prediction table.</p> required <code>prediction</code> <code>list[list]</code> <p>Prediction table to be compared with the target table.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Recall score between [0, 1]. - 0 indicates no cell in the target is in the prediction. - 1 indicates all cells in the target are in the prediction.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; evaluator = CellRecallTag()\n&gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n&gt;&gt;&gt; prediction = [['a', 'b'], ['c', 'd']\n&gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n1.0\n</code></pre> <pre><code>&gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n&gt;&gt;&gt; prediction = [['a', 'x'], ['y', 'd']]\n&gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n0.5\n</code></pre> <pre><code>&gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n&gt;&gt;&gt; prediction = [['a', 'a'], ['b', 'b'], ['c', 'd']]\n&gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n1.0\n</code></pre> Source code in <code>qatch/metrics/cell_recall_tag.py</code> <pre><code>def evaluate_single_no_special_case(self, target: list[list],\n                                    prediction: list[list]) -&gt; float:\n    \"\"\"\n    Calculates the ratio of target cells that are in the prediction.\n    High recall indicates that the model is good at identifying all relevant instances\n    and has a low false negative rate.\n\n    Args:\n        target (list[list]): Target table to be compared with the prediction table.\n        prediction (list[list]): Prediction table to be compared with the target table.\n\n    Returns:\n        float: Recall score between [0, 1].\n            - 0 indicates no cell in the target is in the prediction.\n            - 1 indicates all cells in the target are in the prediction.\n\n    Examples:\n        &gt;&gt;&gt; evaluator = CellRecallTag()\n        &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n        &gt;&gt;&gt; prediction = [['a', 'b'], ['c', 'd']\n        &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n        1.0\n\n        &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n        &gt;&gt;&gt; prediction = [['a', 'x'], ['y', 'd']]\n        &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n        0.5\n\n        &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n        &gt;&gt;&gt; prediction = [['a', 'a'], ['b', 'b'], ['c', 'd']]\n        &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n        1.0\n    \"\"\"\n    target = np.array(target)\n    prediction = np.array(prediction)\n    sum_cell_match = np.sum(np.isin(target, prediction))\n    return round(sum_cell_match / target.size, 3)\n</code></pre>"},{"location":"metrics/#qatch.metrics.TupleCardinalityTag","title":"<code>TupleCardinalityTag</code>","text":"<p>             Bases: <code>AbstractMetric</code></p> Source code in <code>qatch/metrics/tuple_cardinality_tag.py</code> <pre><code>class TupleCardinalityTag(AbstractMetric):\n    def evaluate_single_no_special_case(self,\n                                        target: list[list],\n                                        prediction: list[list]) -&gt; float:\n        \"\"\"\n        Evaluates the ratio of the length of the smaller list to the length of the larger list.\n\n        Calculates the ratio of the length of the target table to the length of the prediction table\n        or vice-versa based on the maximum length to ensure the score falls between 0 and 1.\n\n        Args:\n            target (list[list]): Target table to be compared with the prediction table.\n            prediction (list[list]): Prediction table to be compared with the target table.\n\n        Returns:\n            float: Score between [0, 1].\n                - 0 indicates the target/prediction is zero and the other is not.\n                - 1 indicates the target/prediction is the same size as the other.\n\n        Examples:\n            &gt;&gt;&gt; evaluator = TupleCardinalityTag()\n            &gt;&gt;&gt; target = [[a, b], [c, d], [c, d], [f, g]]\n            &gt;&gt;&gt; prediction = [[a, b], [3, 2]]\n            &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n            0.5  # 2/4\n\n            &gt;&gt;&gt; evaluator = TupleCardinalityTag()\n            &gt;&gt;&gt; target = [[a, b], [3, 2]]\n            &gt;&gt;&gt; prediction = [[a, b], [c, d], [c, d], [f, g]]\n            &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n            0.5\n\n            &gt;&gt;&gt; evaluator = TupleCardinalityTag()\n            &gt;&gt;&gt; target = [[a, b], [3, 2]]\n            &gt;&gt;&gt; prediction = [[a, b], ['c', 'd']]\n            &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n            1.0\n        \"\"\"\n        if len(prediction) &gt;= len(target):\n            # in case we have more elements in the prediction than in the target\n            return round(len(target) / len(prediction), 3)\n\n        # in case we have more elements in the target than in the prediction\n        elif len(prediction) &lt; len(target):\n            return round(len(prediction) / len(target), 3)\n</code></pre>"},{"location":"metrics/#qatch.metrics.TupleCardinalityTag.evaluate_single_no_special_case","title":"<code>evaluate_single_no_special_case(target, prediction)</code>","text":"<p>Evaluates the ratio of the length of the smaller list to the length of the larger list.</p> <p>Calculates the ratio of the length of the target table to the length of the prediction table or vice-versa based on the maximum length to ensure the score falls between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>list[list]</code> <p>Target table to be compared with the prediction table.</p> required <code>prediction</code> <code>list[list]</code> <p>Prediction table to be compared with the target table.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Score between [0, 1]. - 0 indicates the target/prediction is zero and the other is not. - 1 indicates the target/prediction is the same size as the other.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; evaluator = TupleCardinalityTag()\n&gt;&gt;&gt; target = [[a, b], [c, d], [c, d], [f, g]]\n&gt;&gt;&gt; prediction = [[a, b], [3, 2]]\n&gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n0.5  # 2/4\n</code></pre> <pre><code>&gt;&gt;&gt; evaluator = TupleCardinalityTag()\n&gt;&gt;&gt; target = [[a, b], [3, 2]]\n&gt;&gt;&gt; prediction = [[a, b], [c, d], [c, d], [f, g]]\n&gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n0.5\n</code></pre> <pre><code>&gt;&gt;&gt; evaluator = TupleCardinalityTag()\n&gt;&gt;&gt; target = [[a, b], [3, 2]]\n&gt;&gt;&gt; prediction = [[a, b], ['c', 'd']]\n&gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n1.0\n</code></pre> Source code in <code>qatch/metrics/tuple_cardinality_tag.py</code> <pre><code>def evaluate_single_no_special_case(self,\n                                    target: list[list],\n                                    prediction: list[list]) -&gt; float:\n    \"\"\"\n    Evaluates the ratio of the length of the smaller list to the length of the larger list.\n\n    Calculates the ratio of the length of the target table to the length of the prediction table\n    or vice-versa based on the maximum length to ensure the score falls between 0 and 1.\n\n    Args:\n        target (list[list]): Target table to be compared with the prediction table.\n        prediction (list[list]): Prediction table to be compared with the target table.\n\n    Returns:\n        float: Score between [0, 1].\n            - 0 indicates the target/prediction is zero and the other is not.\n            - 1 indicates the target/prediction is the same size as the other.\n\n    Examples:\n        &gt;&gt;&gt; evaluator = TupleCardinalityTag()\n        &gt;&gt;&gt; target = [[a, b], [c, d], [c, d], [f, g]]\n        &gt;&gt;&gt; prediction = [[a, b], [3, 2]]\n        &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n        0.5  # 2/4\n\n        &gt;&gt;&gt; evaluator = TupleCardinalityTag()\n        &gt;&gt;&gt; target = [[a, b], [3, 2]]\n        &gt;&gt;&gt; prediction = [[a, b], [c, d], [c, d], [f, g]]\n        &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n        0.5\n\n        &gt;&gt;&gt; evaluator = TupleCardinalityTag()\n        &gt;&gt;&gt; target = [[a, b], [3, 2]]\n        &gt;&gt;&gt; prediction = [[a, b], ['c', 'd']]\n        &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n        1.0\n    \"\"\"\n    if len(prediction) &gt;= len(target):\n        # in case we have more elements in the prediction than in the target\n        return round(len(target) / len(prediction), 3)\n\n    # in case we have more elements in the target than in the prediction\n    elif len(prediction) &lt; len(target):\n        return round(len(prediction) / len(target), 3)\n</code></pre>"},{"location":"metrics/#qatch.metrics.TupleConstraintTag","title":"<code>TupleConstraintTag</code>","text":"<p>             Bases: <code>AbstractMetric</code></p> Source code in <code>qatch/metrics/tuple_constraint_tag.py</code> <pre><code>class TupleConstraintTag(AbstractMetric):\n    def evaluate_single_no_special_case(self,\n                                        target: list[list],\n                                        prediction: list[list]\n                                        ) -&gt; float:\n        \"\"\"\n        Evaluates the ratio between the cardinality of the target tuples and the prediction.\n        Returns a score between 0 and 1. It is 1 if the schema, the cardinality and the cell values are equal.\n\n        Args:\n            target (list[list]): Target table to be compared with the prediction table.\n            prediction (list[list]): Prediction table to be compared with the target table.\n\n        Returns:\n            float: Score between [0, 1].\n                - 0 indicates NONE of the schema/cardinality/cell_values  are the same in prediction.\n                - 1 indicates the schema, the cardinality and the cell values of the prediction tuples are equal to the target ones.\n\n        Examples:\n            &gt;&gt;&gt; evaluator = TupleConstraintTag()\n            &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n            &gt;&gt;&gt; prediction = [['a', 'b'], ['c', 'd']]\n            &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n            1.0\n\n            &gt;&gt;&gt; evaluator = TupleConstraintTag()\n            &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n            &gt;&gt;&gt; prediction = [['a', 'b'], ['a', 'b'], ['c', 'd']]\n            &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n            0.5  # only ['c', 'd'] is the same in both tables\n\n            &gt;&gt;&gt; evaluator = TupleConstraintTag()\n            &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n            &gt;&gt;&gt; prediction = [['a', 'b'], ['a', 'b'], ['c', 'd'], ['c', 'd']]\n            &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n            0.0\n        \"\"\"\n        target = map(sorted, target)\n        prediction = map(sorted, prediction)\n\n        target = map(tuple, target)\n        prediction = map(tuple, prediction)\n\n        count_targ_dict = Counter(target)\n        count_pred_dict = Counter(prediction)\n\n        cardinality = [count_pred_dict[key] == count for key, count in count_targ_dict.items()]\n\n        return round(sum(cardinality) / len(cardinality), 3)\n</code></pre>"},{"location":"metrics/#qatch.metrics.TupleConstraintTag.evaluate_single_no_special_case","title":"<code>evaluate_single_no_special_case(target, prediction)</code>","text":"<p>Evaluates the ratio between the cardinality of the target tuples and the prediction. Returns a score between 0 and 1. It is 1 if the schema, the cardinality and the cell values are equal.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>list[list]</code> <p>Target table to be compared with the prediction table.</p> required <code>prediction</code> <code>list[list]</code> <p>Prediction table to be compared with the target table.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Score between [0, 1]. - 0 indicates NONE of the schema/cardinality/cell_values  are the same in prediction. - 1 indicates the schema, the cardinality and the cell values of the prediction tuples are equal to the target ones.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; evaluator = TupleConstraintTag()\n&gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n&gt;&gt;&gt; prediction = [['a', 'b'], ['c', 'd']]\n&gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n1.0\n</code></pre> <pre><code>&gt;&gt;&gt; evaluator = TupleConstraintTag()\n&gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n&gt;&gt;&gt; prediction = [['a', 'b'], ['a', 'b'], ['c', 'd']]\n&gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n0.5  # only ['c', 'd'] is the same in both tables\n</code></pre> <pre><code>&gt;&gt;&gt; evaluator = TupleConstraintTag()\n&gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n&gt;&gt;&gt; prediction = [['a', 'b'], ['a', 'b'], ['c', 'd'], ['c', 'd']]\n&gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n0.0\n</code></pre> Source code in <code>qatch/metrics/tuple_constraint_tag.py</code> <pre><code>def evaluate_single_no_special_case(self,\n                                    target: list[list],\n                                    prediction: list[list]\n                                    ) -&gt; float:\n    \"\"\"\n    Evaluates the ratio between the cardinality of the target tuples and the prediction.\n    Returns a score between 0 and 1. It is 1 if the schema, the cardinality and the cell values are equal.\n\n    Args:\n        target (list[list]): Target table to be compared with the prediction table.\n        prediction (list[list]): Prediction table to be compared with the target table.\n\n    Returns:\n        float: Score between [0, 1].\n            - 0 indicates NONE of the schema/cardinality/cell_values  are the same in prediction.\n            - 1 indicates the schema, the cardinality and the cell values of the prediction tuples are equal to the target ones.\n\n    Examples:\n        &gt;&gt;&gt; evaluator = TupleConstraintTag()\n        &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n        &gt;&gt;&gt; prediction = [['a', 'b'], ['c', 'd']]\n        &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n        1.0\n\n        &gt;&gt;&gt; evaluator = TupleConstraintTag()\n        &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n        &gt;&gt;&gt; prediction = [['a', 'b'], ['a', 'b'], ['c', 'd']]\n        &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n        0.5  # only ['c', 'd'] is the same in both tables\n\n        &gt;&gt;&gt; evaluator = TupleConstraintTag()\n        &gt;&gt;&gt; target = [['a', 'b'], ['c', 'd']]\n        &gt;&gt;&gt; prediction = [['a', 'b'], ['a', 'b'], ['c', 'd'], ['c', 'd']]\n        &gt;&gt;&gt; evaluator.evaluate_single_no_special_case(target, prediction)\n        0.0\n    \"\"\"\n    target = map(sorted, target)\n    prediction = map(sorted, prediction)\n\n    target = map(tuple, target)\n    prediction = map(tuple, prediction)\n\n    count_targ_dict = Counter(target)\n    count_pred_dict = Counter(prediction)\n\n    cardinality = [count_pred_dict[key] == count for key, count in count_targ_dict.items()]\n\n    return round(sum(cardinality) / len(cardinality), 3)\n</code></pre>"},{"location":"metrics/#qatch.metrics.TupleOrderTag","title":"<code>TupleOrderTag</code>","text":"<p>             Bases: <code>AbstractMetric</code></p> Source code in <code>qatch/metrics/tuple_order_tag.py</code> <pre><code>class TupleOrderTag(AbstractMetric):\n    def evaluate_single_no_special_case(self,\n                                        target: list[list],\n                                        prediction: list[list]) -&gt; float:\n        \"\"\"\n        Evaluates the similarity in tuple order between the target and prediction.\n        The score is based on the Spearman rank correlation coefficient normalized between 0 and 1.\n        This metric ONLY checks whether the order of the tuples is the same in the target and prediction.\n        Therefore, the elements that are in predictions but nor in target are ignored (and viceversa).\n\n        Args:\n            target (list[list]): Target table to be compared with the prediction table.\n            prediction (list[list]): Prediction table to be compared with the target table.\n\n        Returns:\n            float: Score between [-1, 1].\n            - 1 indicates that the order of rows in prediction is the same as in the target.\n            - 0.5 indicates that there is no correlation between the two lists.\n            - 0 indicates the order of rows in prediction is opposite to the target.\n\n        Examples:\n            &gt;&gt;&gt; evaluator = TupleOrderTag()\n            &gt;&gt;&gt;  target = [['a', 'b'], ['c', 'd']]\n            &gt;&gt;&gt;  prediction = [['c', 'd'], ['a', 'b']]\n            &gt;&gt;&gt; evaluator.evaluate(target, prediction)\n            0.0\n\n            &gt;&gt;&gt; evaluator = TupleOrderTag()\n            &gt;&gt;&gt;  target = [['apple', 'orange'], ['pear']]\n            &gt;&gt;&gt;  prediction = [['pear'], ['apple', 'orange']]\n            &gt;&gt;&gt; evaluator.evaluate(target, prediction)\n            0.0\n\n            &gt;&gt;&gt; evaluator = TupleOrderTag()\n            &gt;&gt;&gt;  target = [['apple', 'orange'], ['pear']]\n            &gt;&gt;&gt;  prediction = [['pear']]\n            &gt;&gt;&gt; evaluator.evaluate(target, prediction)\n            1.0\n        \"\"\"\n\n        # take only prediction that are in target without duplicates\n        # MAINTAINING the order\n        new_pred = []\n        [new_pred.append(pred) for pred in prediction\n         if pred in target and pred not in new_pred]\n        # same for target\n        new_target = []\n        [new_target.append(tar) for tar in target\n         if tar in prediction and tar not in new_target]\n\n        if len(new_target) == 0:\n\n            rho = 0.0\n        else:\n            target_ranks = [i for i in range(len(new_target))]\n            pred_ranks = [new_target.index(row) for row in new_pred]\n\n            diff_rank_squared = [(tar - pred) ** 2\n                                 for tar, pred in zip(target_ranks, pred_ranks)]\n\n            sum_diff_rank_squared = sum(diff_rank_squared)\n\n            n = len(new_target) if len(new_target) &gt; 1 else 2\n            rho = 1 - 6 * sum_diff_rank_squared / (n * (n ** 2 - 1))\n\n        return self.normalize(round(rho, 3))\n\n    @staticmethod\n    def normalize(data: float):\n        data = [-1, data, 1]\n        data = (data - np.min(data)) / (np.max(data) - np.min(data))\n        return data[1]\n</code></pre>"},{"location":"metrics/#qatch.metrics.TupleOrderTag.evaluate_single_no_special_case","title":"<code>evaluate_single_no_special_case(target, prediction)</code>","text":"<p>Evaluates the similarity in tuple order between the target and prediction. The score is based on the Spearman rank correlation coefficient normalized between 0 and 1. This metric ONLY checks whether the order of the tuples is the same in the target and prediction. Therefore, the elements that are in predictions but nor in target are ignored (and viceversa).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>list[list]</code> <p>Target table to be compared with the prediction table.</p> required <code>prediction</code> <code>list[list]</code> <p>Prediction table to be compared with the target table.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Score between [-1, 1].</p> <code>float</code> <ul> <li>1 indicates that the order of rows in prediction is the same as in the target.</li> </ul> <code>float</code> <ul> <li>0.5 indicates that there is no correlation between the two lists.</li> </ul> <code>float</code> <ul> <li>0 indicates the order of rows in prediction is opposite to the target.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; evaluator = TupleOrderTag()\n&gt;&gt;&gt;  target = [['a', 'b'], ['c', 'd']]\n&gt;&gt;&gt;  prediction = [['c', 'd'], ['a', 'b']]\n&gt;&gt;&gt; evaluator.evaluate(target, prediction)\n0.0\n</code></pre> <pre><code>&gt;&gt;&gt; evaluator = TupleOrderTag()\n&gt;&gt;&gt;  target = [['apple', 'orange'], ['pear']]\n&gt;&gt;&gt;  prediction = [['pear'], ['apple', 'orange']]\n&gt;&gt;&gt; evaluator.evaluate(target, prediction)\n0.0\n</code></pre> <pre><code>&gt;&gt;&gt; evaluator = TupleOrderTag()\n&gt;&gt;&gt;  target = [['apple', 'orange'], ['pear']]\n&gt;&gt;&gt;  prediction = [['pear']]\n&gt;&gt;&gt; evaluator.evaluate(target, prediction)\n1.0\n</code></pre> Source code in <code>qatch/metrics/tuple_order_tag.py</code> <pre><code>def evaluate_single_no_special_case(self,\n                                    target: list[list],\n                                    prediction: list[list]) -&gt; float:\n    \"\"\"\n    Evaluates the similarity in tuple order between the target and prediction.\n    The score is based on the Spearman rank correlation coefficient normalized between 0 and 1.\n    This metric ONLY checks whether the order of the tuples is the same in the target and prediction.\n    Therefore, the elements that are in predictions but nor in target are ignored (and viceversa).\n\n    Args:\n        target (list[list]): Target table to be compared with the prediction table.\n        prediction (list[list]): Prediction table to be compared with the target table.\n\n    Returns:\n        float: Score between [-1, 1].\n        - 1 indicates that the order of rows in prediction is the same as in the target.\n        - 0.5 indicates that there is no correlation between the two lists.\n        - 0 indicates the order of rows in prediction is opposite to the target.\n\n    Examples:\n        &gt;&gt;&gt; evaluator = TupleOrderTag()\n        &gt;&gt;&gt;  target = [['a', 'b'], ['c', 'd']]\n        &gt;&gt;&gt;  prediction = [['c', 'd'], ['a', 'b']]\n        &gt;&gt;&gt; evaluator.evaluate(target, prediction)\n        0.0\n\n        &gt;&gt;&gt; evaluator = TupleOrderTag()\n        &gt;&gt;&gt;  target = [['apple', 'orange'], ['pear']]\n        &gt;&gt;&gt;  prediction = [['pear'], ['apple', 'orange']]\n        &gt;&gt;&gt; evaluator.evaluate(target, prediction)\n        0.0\n\n        &gt;&gt;&gt; evaluator = TupleOrderTag()\n        &gt;&gt;&gt;  target = [['apple', 'orange'], ['pear']]\n        &gt;&gt;&gt;  prediction = [['pear']]\n        &gt;&gt;&gt; evaluator.evaluate(target, prediction)\n        1.0\n    \"\"\"\n\n    # take only prediction that are in target without duplicates\n    # MAINTAINING the order\n    new_pred = []\n    [new_pred.append(pred) for pred in prediction\n     if pred in target and pred not in new_pred]\n    # same for target\n    new_target = []\n    [new_target.append(tar) for tar in target\n     if tar in prediction and tar not in new_target]\n\n    if len(new_target) == 0:\n\n        rho = 0.0\n    else:\n        target_ranks = [i for i in range(len(new_target))]\n        pred_ranks = [new_target.index(row) for row in new_pred]\n\n        diff_rank_squared = [(tar - pred) ** 2\n                             for tar, pred in zip(target_ranks, pred_ranks)]\n\n        sum_diff_rank_squared = sum(diff_rank_squared)\n\n        n = len(new_target) if len(new_target) &gt; 1 else 2\n        rho = 1 - 6 * sum_diff_rank_squared / (n * (n ** 2 - 1))\n\n    return self.normalize(round(rho, 3))\n</code></pre>"},{"location":"sql_generator/","title":"Step 1: SQL Generator","text":""},{"location":"sql_generator/#qatch.test_generator.TestGenerator","title":"<code>TestGenerator</code>","text":"<p>The interface to connect the MultipleDatabase with the SQL generators. Use this class to generate queries and questions from the databases.</p> <p>Attributes:</p> Name Type Description <code>databases</code> <code>MultipleDatabases</code> <p>The MultipleDatabases object representing the database connections.</p> Source code in <code>qatch/test_generator.py</code> <pre><code>class TestGenerator:\n    \"\"\"\n    The interface to connect the MultipleDatabase with the SQL generators.\n    Use this class to generate queries and questions from the databases.\n\n    Attributes:\n        databases (MultipleDatabases): The MultipleDatabases object representing the database connections.\n    \"\"\"\n\n    def __init__(self, databases: MultipleDatabases):\n        \"\"\"\n        Initialize the TestGenerator with a MultipleDatabases object.\n\n        Args:\n            databases (MultipleDatabases): Object representing database connections.\n        \"\"\"\n        self.databases = databases\n\n        self._generators = {'select': SelectGenerator,\n                            'orderby': OrderByGenerator,\n                            'distinct': DistinctGenerator,\n                            'where': WhereGenerator,\n                            'groupby': GroupByGenerator,\n                            'having': HavingGenerator,\n                            'simpleAgg': SimpleAggGenerator,\n                            'nullCount': NullGenerator}\n\n    def generate(self,\n                 generators: list[str] | str | None = None,\n                 db_names: str | list[str] | None = None,\n                 seed=2023\n                 ) -&gt; pd.DataFrame:\n        \"\"\"\n        Generate test queries and questions for specified generators and databases.\n\n        Args:\n            generators (list[str] | str | None): Optional. A list of generator names to be used.\n                                                  Default is to use all available generators\n                                                  ['select', 'orderby', 'distinct', 'where', 'groupby',\n                                                   'having', 'simpleAgg', 'nullCount'].\n            db_names (str | list[str] | None): Optional. The name or list of names of databases to generate tests for.\n                                                Default is to use all available databases.\n            seed (int): Optional. Seed value for randomization. Default is 2023.\n\n        Returns:\n            pd.DataFrame: A DataFrame containing generated test queries, questions, and related information.\n\n        Examples:\n            Given a MultipleDatabases object \"database\", with three databases 'sakila', 'world', and 'employees'\n            &gt;&gt;&gt; generator = TestGenerator(databases)\n            &gt;&gt;&gt; tests_df = generator.generate(generators=['select', 'orderby'], db_names=['sakila', 'world'])\n            generate tests only for select and orderby generators, and only for sakila and world databases\n        \"\"\"\n        # TODO possible change of the db_name, add dictionary to specify also the tbl_names\n        generators, db_names, = self._init_params(generators, db_names)\n\n        tests_df_list = []\n        for db_name in tqdm(db_names, desc='Generating test for each database'):\n            # for each db_name\n            for generator in generators:\n                # init generator\n                db = self.databases[db_name]\n                generator = self._generators[generator](db, seed)\n                for tbl in db.table_names:\n                    sql_generated = generator.sql_generate(tbl)\n                    df = self._build_df(db_name, tbl, sql_generated)\n                    tests_df_list.append(df)\n\n        tests_df = pd.concat(tests_df_list, ignore_index=True)\n        return tests_df\n\n    def _init_params(self, generators: list[str] | str | None,\n                     db_names: str | list[str] | None) -&gt; tuple[list[str], list[str]]:\n        \"\"\"\n        Validate and initialize generator names and database names.\n\n        Args:\n            generators (list[str] | str | None): The list of generator names or a single generator name.\n            db_names (str | list[str] | None): The name or list of names of databases to generate tests for.\n\n        Returns:\n            tuple[list[str], list[str]]: Validated generator names and database names.\n        \"\"\"\n        # generators check\n        if generators is None:\n            generators = list(self._generators.keys())\n        else:\n            if isinstance(generators, str):\n                generators = [generators]\n            for generator in generators:\n                if generator not in self._generators.keys():\n                    raise KeyError(f'Generators must be one of {list(self._generators.keys())}')\n\n        # db_names check\n        available_dbs = [x.lower() for x in self.databases.get_db_names()]\n        if db_names is None:\n            db_names = available_dbs\n        else:\n            if isinstance(db_names, str):\n                db_names = [db_names]\n            db_names = [x.lower() for x in db_names]\n            for db_name in db_names:\n                if db_name not in available_dbs:\n                    raise KeyError(f'Database name \"{db_name}\" must be one of {available_dbs}')\n        return generators, db_names\n\n    @staticmethod\n    def _build_df(db_name: str, tbl_name: str, sql_generated: dict[str, list]) -&gt; pd.DataFrame:\n        \"\"\"\n        Build a DataFrame from generated SQL queries, questions, and related information.\n\n        Args:\n            db_name (str): The name of the database.\n            tbl_name (str): The name of the table in the database.\n            sql_generated (dict[str, list]): A dictionary containing generated SQL tags, queries, and questions.\n\n        Returns:\n            pd.DataFrame: A DataFrame containing generated test queries, questions, and related information.\n        \"\"\"\n\n        sql_tags = sql_generated['sql_tags']\n        queries = sql_generated['queries']\n        questions = sql_generated['questions']\n        return pd.DataFrame({\n            'db_id': [db_name] * len(sql_tags),\n            'tbl_name': [tbl_name] * len(sql_tags),\n            'sql_tags': sql_tags,\n            'query': queries,\n            'question': questions\n        })\n</code></pre>"},{"location":"sql_generator/#qatch.test_generator.TestGenerator.__init__","title":"<code>__init__(databases)</code>","text":"<p>Initialize the TestGenerator with a MultipleDatabases object.</p> <p>Parameters:</p> Name Type Description Default <code>databases</code> <code>MultipleDatabases</code> <p>Object representing database connections.</p> required Source code in <code>qatch/test_generator.py</code> <pre><code>def __init__(self, databases: MultipleDatabases):\n    \"\"\"\n    Initialize the TestGenerator with a MultipleDatabases object.\n\n    Args:\n        databases (MultipleDatabases): Object representing database connections.\n    \"\"\"\n    self.databases = databases\n\n    self._generators = {'select': SelectGenerator,\n                        'orderby': OrderByGenerator,\n                        'distinct': DistinctGenerator,\n                        'where': WhereGenerator,\n                        'groupby': GroupByGenerator,\n                        'having': HavingGenerator,\n                        'simpleAgg': SimpleAggGenerator,\n                        'nullCount': NullGenerator}\n</code></pre>"},{"location":"sql_generator/#qatch.test_generator.TestGenerator.generate","title":"<code>generate(generators=None, db_names=None, seed=2023)</code>","text":"<p>Generate test queries and questions for specified generators and databases.</p> <p>Parameters:</p> Name Type Description Default <code>generators</code> <code>list[str] | str | None</code> <p>Optional. A list of generator names to be used.                                   Default is to use all available generators                                   ['select', 'orderby', 'distinct', 'where', 'groupby',                                    'having', 'simpleAgg', 'nullCount'].</p> <code>None</code> <code>db_names</code> <code>str | list[str] | None</code> <p>Optional. The name or list of names of databases to generate tests for.                                 Default is to use all available databases.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Optional. Seed value for randomization. Default is 2023.</p> <code>2023</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing generated test queries, questions, and related information.</p> <p>Examples:</p> <p>Given a MultipleDatabases object \"database\", with three databases 'sakila', 'world', and 'employees'</p> <pre><code>&gt;&gt;&gt; generator = TestGenerator(databases)\n&gt;&gt;&gt; tests_df = generator.generate(generators=['select', 'orderby'], db_names=['sakila', 'world'])\ngenerate tests only for select and orderby generators, and only for sakila and world databases\n</code></pre> Source code in <code>qatch/test_generator.py</code> <pre><code>def generate(self,\n             generators: list[str] | str | None = None,\n             db_names: str | list[str] | None = None,\n             seed=2023\n             ) -&gt; pd.DataFrame:\n    \"\"\"\n    Generate test queries and questions for specified generators and databases.\n\n    Args:\n        generators (list[str] | str | None): Optional. A list of generator names to be used.\n                                              Default is to use all available generators\n                                              ['select', 'orderby', 'distinct', 'where', 'groupby',\n                                               'having', 'simpleAgg', 'nullCount'].\n        db_names (str | list[str] | None): Optional. The name or list of names of databases to generate tests for.\n                                            Default is to use all available databases.\n        seed (int): Optional. Seed value for randomization. Default is 2023.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing generated test queries, questions, and related information.\n\n    Examples:\n        Given a MultipleDatabases object \"database\", with three databases 'sakila', 'world', and 'employees'\n        &gt;&gt;&gt; generator = TestGenerator(databases)\n        &gt;&gt;&gt; tests_df = generator.generate(generators=['select', 'orderby'], db_names=['sakila', 'world'])\n        generate tests only for select and orderby generators, and only for sakila and world databases\n    \"\"\"\n    # TODO possible change of the db_name, add dictionary to specify also the tbl_names\n    generators, db_names, = self._init_params(generators, db_names)\n\n    tests_df_list = []\n    for db_name in tqdm(db_names, desc='Generating test for each database'):\n        # for each db_name\n        for generator in generators:\n            # init generator\n            db = self.databases[db_name]\n            generator = self._generators[generator](db, seed)\n            for tbl in db.table_names:\n                sql_generated = generator.sql_generate(tbl)\n                df = self._build_df(db_name, tbl, sql_generated)\n                tests_df_list.append(df)\n\n    tests_df = pd.concat(tests_df_list, ignore_index=True)\n    return tests_df\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.DistinctGenerator","title":"<code>DistinctGenerator</code>","text":"<p>             Bases: <code>AbstractSqlGenerator</code></p> <p>A class for generating DISTINCT SQL queries and corresponding questions based on categorical columns of a database table.</p> <p>Attributes:</p> Name Type Description <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> <code>sql_generated</code> <code>dict</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}</p> Source code in <code>qatch/sql_generator/distinct_generator.py</code> <pre><code>class DistinctGenerator(AbstractSqlGenerator):\n    \"\"\"\n    A class for generating DISTINCT SQL queries and corresponding questions based on\n    categorical columns of a database table.\n\n    Attributes:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        sql_generated (dict): A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n    \"\"\"\n\n    def __int__(self, database: SingleDatabase, *args, **kwargs):\n        \"\"\"\n        Initializes the DistinctSqlGenerator object.\n\n        Args:\n            database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        \"\"\"\n\n        super().__init__(database, *args, **kwargs)\n\n    def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n        \"\"\"\n        Generates DISTINCT SQL queries and corresponding questions based on categorical columns of a table.\n        Generates two distinct tags: DISTINCT-SINGLE and DISTINCT-MULT only for the categorical columns.\n\n        Args:\n            table_name (str): The name of the table in the database.\n\n        Returns:\n            dict: A dictionary containing generated SQL tags, queries, and questions.\n                Format: {\"sql_tags\": List[str], \"queries\": List[str], \"questions\": List[str]}\n\n        Examples:\n            Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"names\"\n            &gt;&gt;&gt; generator = DistinctGenerator(database)\n            &gt;&gt;&gt; generator._distinct_single_col(\"table_name\", [\"colors\"])\n            &gt;&gt;&gt; generator.sql_generated\n            {\"sql_tags\": [\"DISTINCT-SINGLE\"],\n            \"queries\": [\"SELECT DISTINCT \\\"colors\\\" FROM \\\"table_name\\\"\"],\n            \"questions\": [\"Show the different \\\"colors\\\" in the table table_name\"]}\n            &gt;&gt;&gt; generator_distinct_mult_col(\"table_name\", [\"colors\", \"names\"])\n            &gt;&gt;&gt; generator.sql_generated\n            {\"sql_tags\": [\"DISTINCT-MULT\"],\n            \"queries\": [\"SELECT DISTINCT \\\"colors\\\", \\\"names\\\" FROM \\\"table_name\\\"\"],\n            \"questions\": [\"Show the different \\\"colors\\\", \\\"names\\\" in the table table_name\"]}\n        \"\"\"\n        _, cat_cols, _ = self._sample_cat_num_cols(table_name)\n        self._distinct_single_col(table_name, cat_cols)\n        self._distinct_mult_col(table_name, cat_cols)\n        return self.sql_generated\n\n    def _distinct_single_col(self, table_name: str, cat_columns: list):\n        \"\"\"\n        Generates DISTINCT SQL queries and questions for individual categorical columns.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            cat_columns (List[str]): List of categorical column names.\n        \"\"\"\n        queries = [f'SELECT DISTINCT \"{col}\" FROM \"{table_name}\"'\n                   for col in cat_columns]\n\n        questions = [f'Show the different \"{col}\" in the table {table_name}'\n                     for col in cat_columns]\n\n        sql_tags = ['DISTINCT-SINGLE'] * len(queries)\n        self.append_sql_generated(sql_tags=sql_tags, queries=queries, questions=questions)\n\n    def _distinct_mult_col(self, table_name: str, cat_columns: list):\n        \"\"\"\n        Generates DISTINCT SQL queries and questions for combinations of multiple categorical columns.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            cat_columns (List[str]): List of categorical column names.\n        \"\"\"\n        combinations = self._comb_random(cat_columns)\n        queries = [f'SELECT DISTINCT {self._get_col_comb_str(comb)} FROM \"{table_name}\"'\n                   for comb in combinations]\n\n        questions = [f'Show the different {self._get_col_comb_str(comb)} in the table \"{table_name}\"'\n                     for comb in combinations]\n\n        sql_tags = ['DISTINCT-MULT'] * len(queries)\n        self.append_sql_generated(sql_tags=sql_tags, queries=queries, questions=questions)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.DistinctGenerator.__int__","title":"<code>__int__(database, *args, **kwargs)</code>","text":"<p>Initializes the DistinctSqlGenerator object.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> required Source code in <code>qatch/sql_generator/distinct_generator.py</code> <pre><code>def __int__(self, database: SingleDatabase, *args, **kwargs):\n    \"\"\"\n    Initializes the DistinctSqlGenerator object.\n\n    Args:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n    \"\"\"\n\n    super().__init__(database, *args, **kwargs)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.DistinctGenerator.sql_generate","title":"<code>sql_generate(table_name)</code>","text":"<p>Generates DISTINCT SQL queries and corresponding questions based on categorical columns of a table. Generates two distinct tags: DISTINCT-SINGLE and DISTINCT-MULT only for the categorical columns.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table in the database.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, list]</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": List[str], \"queries\": List[str], \"questions\": List[str]}</p> <p>Examples:</p> <p>Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"names\"</p> <pre><code>&gt;&gt;&gt; generator = DistinctGenerator(database)\n&gt;&gt;&gt; generator._distinct_single_col(\"table_name\", [\"colors\"])\n&gt;&gt;&gt; generator.sql_generated\n{\"sql_tags\": [\"DISTINCT-SINGLE\"],\n\"queries\": [\"SELECT DISTINCT \"colors\" FROM \"table_name\"\"],\n\"questions\": [\"Show the different \"colors\" in the table table_name\"]}\n&gt;&gt;&gt; generator_distinct_mult_col(\"table_name\", [\"colors\", \"names\"])\n&gt;&gt;&gt; generator.sql_generated\n{\"sql_tags\": [\"DISTINCT-MULT\"],\n\"queries\": [\"SELECT DISTINCT \"colors\", \"names\" FROM \"table_name\"\"],\n\"questions\": [\"Show the different \"colors\", \"names\" in the table table_name\"]}\n</code></pre> Source code in <code>qatch/sql_generator/distinct_generator.py</code> <pre><code>def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n    \"\"\"\n    Generates DISTINCT SQL queries and corresponding questions based on categorical columns of a table.\n    Generates two distinct tags: DISTINCT-SINGLE and DISTINCT-MULT only for the categorical columns.\n\n    Args:\n        table_name (str): The name of the table in the database.\n\n    Returns:\n        dict: A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": List[str], \"queries\": List[str], \"questions\": List[str]}\n\n    Examples:\n        Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"names\"\n        &gt;&gt;&gt; generator = DistinctGenerator(database)\n        &gt;&gt;&gt; generator._distinct_single_col(\"table_name\", [\"colors\"])\n        &gt;&gt;&gt; generator.sql_generated\n        {\"sql_tags\": [\"DISTINCT-SINGLE\"],\n        \"queries\": [\"SELECT DISTINCT \\\"colors\\\" FROM \\\"table_name\\\"\"],\n        \"questions\": [\"Show the different \\\"colors\\\" in the table table_name\"]}\n        &gt;&gt;&gt; generator_distinct_mult_col(\"table_name\", [\"colors\", \"names\"])\n        &gt;&gt;&gt; generator.sql_generated\n        {\"sql_tags\": [\"DISTINCT-MULT\"],\n        \"queries\": [\"SELECT DISTINCT \\\"colors\\\", \\\"names\\\" FROM \\\"table_name\\\"\"],\n        \"questions\": [\"Show the different \\\"colors\\\", \\\"names\\\" in the table table_name\"]}\n    \"\"\"\n    _, cat_cols, _ = self._sample_cat_num_cols(table_name)\n    self._distinct_single_col(table_name, cat_cols)\n    self._distinct_mult_col(table_name, cat_cols)\n    return self.sql_generated\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.GroupByGenerator","title":"<code>GroupByGenerator</code>","text":"<p>             Bases: <code>AbstractSqlGenerator</code></p> <p>A class for generating SQL queries and corresponding questions based on group-by operations performed on categorical and numerical columns of a database table.</p> <p>Attributes:</p> Name Type Description <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> <code>sql_generated</code> <code>dict</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}</p> Source code in <code>qatch/sql_generator/groupby_generator.py</code> <pre><code>class GroupByGenerator(AbstractSqlGenerator):\n    \"\"\"\n    A class for generating SQL queries and corresponding questions based on group-by operations\n    performed on categorical and numerical columns of a database table.\n\n    Attributes:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        sql_generated (dict): A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n    \"\"\"\n\n    def __init__(self, database: SingleDatabase, seed=2023):\n        \"\"\"\n        Initializes the GroupBy object.\n\n        Args:\n            database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n            seed (int): The seed to use for the random number generator.\n        \"\"\"\n        super().__init__(database, seed=2023)\n\n    def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n        \"\"\"\n        Generates Group By queries and corresponding questions for both categorical and numerical columns.\n\n        Args:\n            table_name (str): The name of the table in the database.\n\n        Returns:\n            dict: A dictionary containing generated SQL tags, queries, and questions.\n                Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n\n        Examples:\n            Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"\n            &gt;&gt;&gt; generator = GroupByGenerator(database)\n            &gt;&gt;&gt; generator._build_group_by_no_agg(\"table_name\", [\"colors\"])\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"GROUPBY-NO-AGGR\"],\n                \"queries\": [\"SELECT \\\"colors\\\" FROM \\\"table_name\\\" GROUP BY \\\"colors\\\"\"],\n                \"questions\": [\"Show all \\\"colors\\\" in the table \"table_name\" for each \\\"colors\\\"\"]\n            }\n            &gt;&gt;&gt; generator._build_group_by_with_count(\"table_name\", [\"colors\"])\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"GROUPBY-COUNT\"],\n                \"queries\": [\"SELECT \\\"colors\\\", COUNT(*) FROM \\\"table_name\\\" GROUP BY \\\"colors\\\"\"],\n                \"questions\": [\"For each \\\"colors\\\", count the number of rows in table \"table_name\"\"]\n            }\n            &gt;&gt;&gt; generator._build_group_by_with_agg(\"table_name\")\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"GROUPBY-AGG-MIN\", \"GROUPBY-AGG-MAX\", \"GROUPBY-AGG-AVG\", \"GROUPBY-AGG-SUM\"],\n                \"queries\": [\n                    \"SELECT \\\"colors\\\", MIN(\\\"numbers\\\") FROM \\\"table_name\\\" GROUP BY \\\"colors\\\"\",\n                    \"SELECT \\\"colors\\\", MAX(\\\"numbers\\\") FROM \\\"table_name\\\" GROUP BY \\\"colors\\\"\",\n                    \"SELECT \\\"colors\\\", AVG(\\\"numbers\\\") FROM \\\"table_name\\\" GROUP BY \\\"colors\\\"\",\n                    \"SELECT \\\"colors\\\", SUM(\\\"numbers\\\") FROM \\\"table_name\\\" GROUP BY \\\"colors\\\"\"\n                ],\n                \"questions\": [\n                    \"For each \\\"colors\\\", find the min of \\\"numbers\\\" in table \"table_name\"\",\n                    \"For each \\\"colors\\\", find the max of \\\"numbers\\\" in table \"table_name\"\",\n                    \"For each \\\"colors\\\", find the avg of \\\"numbers\\\" in table \"table_name\"\",\n                    \"For each \\\"colors\\\", find the sum of \\\"numbers\\\" in table \"table_name\"\"\n                ]\n            }\n        \"\"\"\n        self.empty_sql_generated()\n        df, cat_cols, num_cols = self._sample_cat_num_cols(table_name)\n        self._build_group_by_no_agg(table_name, cat_cols)\n        self._build_group_by_with_count(table_name, cat_cols)\n        self._build_group_by_with_agg(table_name)\n        return self.sql_generated\n\n    def _build_group_by_no_agg(self, table_name: str, cat_cols: list):\n        \"\"\"\n        Generate group-by SQL queries and questions without aggregation\n        for random combinations of categorical columns.\n        The query result is the same as Distinct.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            cat_cols (List[str]): List of categorical columns.\n        \"\"\"\n        random_combinations = self._comb_random(cat_cols)\n\n        questions = [f'Show all {self._get_col_comb_str(comb)}' \\\n                     f' in the table \"{table_name}\" for each {self._get_col_comb_str(comb)}'\n                     for comb in random_combinations]\n\n        queries = [f'SELECT {self._get_col_comb_str(comb)} FROM ' \\\n                   f'\"{table_name}\" GROUP BY {self._get_col_comb_str(comb)}'\n                   for comb in random_combinations]\n\n        sql_tags = ['GROUPBY-NO-AGGR'] * len(queries)\n\n        self.append_sql_generated(sql_tags=sql_tags, queries=queries,\n                                  questions=questions)\n\n    def _build_group_by_with_count(self, table_name: str, cat_cols: list):\n        \"\"\"\n        Generate group-by SQL queries and questions with count aggregation for categorical columns.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            cat_cols (List[str]): List of categorical columns.\n        \"\"\"\n        questions = [f'For each \"{col}\", count the number of rows in table \"{table_name}\"'\n                     for col in cat_cols]\n        queries = [f'SELECT \"{col}\", COUNT(*) FROM \"{table_name}\" GROUP BY \"{col}\"'\n                   for col in cat_cols]\n        sql_tags = ['GROUPBY-COUNT'] * len(queries)\n\n        self.append_sql_generated(sql_tags=sql_tags, queries=queries,\n                                  questions=questions)\n\n    def _build_group_by_with_agg(self, table_name: str):\n        \"\"\"\n        Generate group-by SQL queries and questions with aggregation for numerical columns.\n\n        Args:\n            table_name (str): The name of the table in the database.\n        \"\"\"\n        # with sample == 2 we get 4 tests for each aggregation -&gt; 4*4 = 16 tests\n        # with sample == 3 we get 9 tests for each aggregation -&gt; 9*4 = 36 tests\n        _, cat_cols, num_cols = self._sample_cat_num_cols(table_name, sample=2)\n        for agg in ['min', 'max', 'avg', 'sum']:\n            questions = [f'For each \"{c_col}\", find the {agg} of \"{n_col}\" in table \"{table_name}\"'\n                         for c_col in cat_cols\n                         for n_col in num_cols]\n\n            queries = [f'SELECT \"{c_col}\", {agg.upper()}(\"{n_col}\") FROM \"{table_name}\" GROUP BY \"{c_col}\"'\n                       for c_col in cat_cols\n                       for n_col in num_cols]\n\n            sql_tags = [f'GROUPBY-AGG-{agg.upper()}'] * len(queries)\n\n            self.append_sql_generated(sql_tags=sql_tags, queries=queries,\n                                      questions=questions)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.GroupByGenerator.__init__","title":"<code>__init__(database, seed=2023)</code>","text":"<p>Initializes the GroupBy object.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> required <code>seed</code> <code>int</code> <p>The seed to use for the random number generator.</p> <code>2023</code> Source code in <code>qatch/sql_generator/groupby_generator.py</code> <pre><code>def __init__(self, database: SingleDatabase, seed=2023):\n    \"\"\"\n    Initializes the GroupBy object.\n\n    Args:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        seed (int): The seed to use for the random number generator.\n    \"\"\"\n    super().__init__(database, seed=2023)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.GroupByGenerator.sql_generate","title":"<code>sql_generate(table_name)</code>","text":"<p>Generates Group By queries and corresponding questions for both categorical and numerical columns.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table in the database.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, list]</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}</p> <p>Examples:</p> <p>Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"</p> <pre><code>&gt;&gt;&gt; generator = GroupByGenerator(database)\n&gt;&gt;&gt; generator._build_group_by_no_agg(\"table_name\", [\"colors\"])\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"GROUPBY-NO-AGGR\"],\n    \"queries\": [\"SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\"\"],\n    \"questions\": [\"Show all \"colors\" in the table \"table_name\" for each \"colors\"\"]\n}\n&gt;&gt;&gt; generator._build_group_by_with_count(\"table_name\", [\"colors\"])\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"GROUPBY-COUNT\"],\n    \"queries\": [\"SELECT \"colors\", COUNT(*) FROM \"table_name\" GROUP BY \"colors\"\"],\n    \"questions\": [\"For each \"colors\", count the number of rows in table \"table_name\"\"]\n}\n&gt;&gt;&gt; generator._build_group_by_with_agg(\"table_name\")\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"GROUPBY-AGG-MIN\", \"GROUPBY-AGG-MAX\", \"GROUPBY-AGG-AVG\", \"GROUPBY-AGG-SUM\"],\n    \"queries\": [\n        \"SELECT \"colors\", MIN(\"numbers\") FROM \"table_name\" GROUP BY \"colors\"\",\n        \"SELECT \"colors\", MAX(\"numbers\") FROM \"table_name\" GROUP BY \"colors\"\",\n        \"SELECT \"colors\", AVG(\"numbers\") FROM \"table_name\" GROUP BY \"colors\"\",\n        \"SELECT \"colors\", SUM(\"numbers\") FROM \"table_name\" GROUP BY \"colors\"\"\n    ],\n    \"questions\": [\n        \"For each \"colors\", find the min of \"numbers\" in table \"table_name\"\",\n        \"For each \"colors\", find the max of \"numbers\" in table \"table_name\"\",\n        \"For each \"colors\", find the avg of \"numbers\" in table \"table_name\"\",\n        \"For each \"colors\", find the sum of \"numbers\" in table \"table_name\"\"\n    ]\n}\n</code></pre> Source code in <code>qatch/sql_generator/groupby_generator.py</code> <pre><code>def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n    \"\"\"\n    Generates Group By queries and corresponding questions for both categorical and numerical columns.\n\n    Args:\n        table_name (str): The name of the table in the database.\n\n    Returns:\n        dict: A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n\n    Examples:\n        Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"\n        &gt;&gt;&gt; generator = GroupByGenerator(database)\n        &gt;&gt;&gt; generator._build_group_by_no_agg(\"table_name\", [\"colors\"])\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"GROUPBY-NO-AGGR\"],\n            \"queries\": [\"SELECT \\\"colors\\\" FROM \\\"table_name\\\" GROUP BY \\\"colors\\\"\"],\n            \"questions\": [\"Show all \\\"colors\\\" in the table \"table_name\" for each \\\"colors\\\"\"]\n        }\n        &gt;&gt;&gt; generator._build_group_by_with_count(\"table_name\", [\"colors\"])\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"GROUPBY-COUNT\"],\n            \"queries\": [\"SELECT \\\"colors\\\", COUNT(*) FROM \\\"table_name\\\" GROUP BY \\\"colors\\\"\"],\n            \"questions\": [\"For each \\\"colors\\\", count the number of rows in table \"table_name\"\"]\n        }\n        &gt;&gt;&gt; generator._build_group_by_with_agg(\"table_name\")\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"GROUPBY-AGG-MIN\", \"GROUPBY-AGG-MAX\", \"GROUPBY-AGG-AVG\", \"GROUPBY-AGG-SUM\"],\n            \"queries\": [\n                \"SELECT \\\"colors\\\", MIN(\\\"numbers\\\") FROM \\\"table_name\\\" GROUP BY \\\"colors\\\"\",\n                \"SELECT \\\"colors\\\", MAX(\\\"numbers\\\") FROM \\\"table_name\\\" GROUP BY \\\"colors\\\"\",\n                \"SELECT \\\"colors\\\", AVG(\\\"numbers\\\") FROM \\\"table_name\\\" GROUP BY \\\"colors\\\"\",\n                \"SELECT \\\"colors\\\", SUM(\\\"numbers\\\") FROM \\\"table_name\\\" GROUP BY \\\"colors\\\"\"\n            ],\n            \"questions\": [\n                \"For each \\\"colors\\\", find the min of \\\"numbers\\\" in table \"table_name\"\",\n                \"For each \\\"colors\\\", find the max of \\\"numbers\\\" in table \"table_name\"\",\n                \"For each \\\"colors\\\", find the avg of \\\"numbers\\\" in table \"table_name\"\",\n                \"For each \\\"colors\\\", find the sum of \\\"numbers\\\" in table \"table_name\"\"\n            ]\n        }\n    \"\"\"\n    self.empty_sql_generated()\n    df, cat_cols, num_cols = self._sample_cat_num_cols(table_name)\n    self._build_group_by_no_agg(table_name, cat_cols)\n    self._build_group_by_with_count(table_name, cat_cols)\n    self._build_group_by_with_agg(table_name)\n    return self.sql_generated\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.HavingGenerator","title":"<code>HavingGenerator</code>","text":"<p>             Bases: <code>AbstractSqlGenerator</code></p> <p>A class for generating HAVING SQL queries and corresponding questions based on a database table.</p> <p>Attributes:</p> Name Type Description <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> <code>sql_generated</code> <code>dict</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}</p> Source code in <code>qatch/sql_generator/having_generator.py</code> <pre><code>class HavingGenerator(AbstractSqlGenerator):\n    \"\"\"\n    A class for generating HAVING SQL queries and corresponding questions based on a database table.\n\n    Attributes:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        sql_generated (dict): A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n    \"\"\"\n\n    def __init__(self, database: SingleDatabase, seed=2023):\n        \"\"\"\n        Initializes the HavingGenerator object.\n\n        Args:\n            database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n            seed (int): The seed value for randomization. Default is 2023.\n        \"\"\"\n        super().__init__(database, seed)\n\n    def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n        \"\"\"\n        Generate HAVING SQL queries and corresponding questions for categorical and numerical columns.\n\n        Args:\n            table_name (str): The name of the table in the database.\n\n        Returns:\n            dict: A dictionary containing generated SQL tags, queries, and questions.\n                Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n\n        Examples:\n            Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"\n            and (i) the average number of rows for each category in \"colors\" is 2\n            (ii) the mean of the average numbers for each category is 5\n            (iii) the average sum of numbers for each category is 10:\n            &gt;&gt;&gt; generator = HavingGenerator(database)\n            &gt;&gt;&gt; generator._build_having_count(table_name, [\"colors\"], df)\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"HAVING-COUNT-GR\", \"HAVING-COUNT-LS\", \"HAVING-COUNT-EQ\"],\n                \"queries\": [\n                    'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING count(*) &gt;= '2'',\n                    'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING count(*) &lt;= '2'',\n                    'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING count(*) = '2''\n                ],\n                \"questions\": [\n                    'Find all the \"colors\" that have at least 2 records in table \"table_name\"',\n                    'Find all the \"colors\" that have at most 2 records in table \"table_name\"',\n                    'Find all the \"colors\" that have exactly 2 records in table \"table_name\"'\n                ]\n            }\n            &gt;&gt;&gt; generator._build_having_agg(table_name, [\"colors\"], [\"numbers\"], df)\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"HAVING-AGG-AVG-GR\", \"HAVING-AGG-AVG-LS\", \"HAVING-AGG-SUM-GR\", \"HAVING-AGG-SUM-LS\"],\n                \"queries\": [\n                    'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING AVG(\"numbers\") &gt;= '5.0'',\n                    'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING AVG(\"numbers\") &lt;= '5.0'',\n                    'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING SUM(\"numbers\") &gt;= '10.0'',\n                    'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING SUM(\"numbers\") &lt;= '10.0''\n                ],\n                \"questions\": [\n                    'List the \"colors\" which average \"numbers\" is at least 5.0 in table \"table_name\"',\n                    'List the \"colors\" which average \"numbers\" is at most 5.0 in table \"table_name\"',\n                    'List the \"colors\" which summation of \"numbers\" is at least 5.0 in table \"table_name\"',\n                    'List the \"colors\" which summation of \"numbers\" is at most 5.0 in table \"table_name\"'\n                ]\n            }\n        \"\"\"\n        self.empty_sql_generated()\n        df, cat_cols, num_cols = self._sample_cat_num_cols(table_name)\n        self._build_having_count(table_name, cat_cols, df)\n        self._build_having_agg(table_name, cat_cols, num_cols, df)\n        return self.sql_generated\n\n    def _build_having_count(self, table_name: str, cat_cols: list, df: pd.DataFrame):\n        \"\"\"\n        Build HAVING SQL queries and questions for categorical columns based on row counts.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            cat_cols (list): List of categorical columns.\n            df (pd.DataFrame): The DataFrame containing the data.\n        \"\"\"\n\n        for cat_col in cat_cols:\n            # get a mean count of the category cat_col\n            mean_count = self._get_average_of_count_cat_col(table_name, cat_col)\n            # int(df.groupby(cat_col).count().mean().values[0])\n            queries = [\n                f\"\"\"SELECT \"{cat_col}\" FROM \"{table_name}\" GROUP BY \"{cat_col}\" HAVING count(*) &gt;= '{mean_count}'\"\"\",\n                f\"\"\"SELECT \"{cat_col}\" FROM \"{table_name}\" GROUP BY \"{cat_col}\" HAVING count(*) &lt;= '{mean_count}'\"\"\",\n                f\"\"\"SELECT \"{cat_col}\" FROM \"{table_name}\" GROUP BY \"{cat_col}\" HAVING count(*) = '{mean_count}'\"\"\"\n            ]\n\n            questions = [\n                f'Find all the \"{cat_col}\" that have at least {mean_count} records in table \"{table_name}\"',\n                f'Find all the \"{cat_col}\" that have at most {mean_count} records in table \"{table_name}\"',\n                f'Find all the \"{cat_col}\" that have exactly {mean_count} records in table \"{table_name}\"'\n            ]\n\n            sql_tags = ['HAVING-COUNT-GR', 'HAVING-COUNT-LS', 'HAVING-COUNT-EQ']\n\n            self.append_sql_generated(sql_tags, queries, questions)\n\n    def _build_having_agg(self, table_name: str, cat_cols: list, num_cols: list, df: pd.DataFrame):\n        \"\"\"\n        Build HAVING SQL queries and questions for numerical columns based on aggregations.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            cat_cols (list): List of categorical columns.\n            num_cols (list): List of numerical columns.\n            df (pd.DataFrame): The DataFrame containing the data.\n        \"\"\"\n        # with sample == 2 we get 4 tests for each aggregation -&gt; 4*4 = 16 tests\n        # with sample == 3 we get 9 tests for each aggregation -&gt; 9*4 = 36 tests\n        for cat_col in cat_cols:\n            # the mean for each grouped category\n            # mean_sum = df.groupby(cat_col).sum(numeric_only=True)\n            # mean_mean = df.groupby(cat_col).mean(numeric_only=True)\n            for num_col in num_cols:\n                # the mean of sum for the grouped category\n                # mean_mean_sum = round(mean_sum[num_col].mean(), 2)\n                # mean_mean_mean = round(mean_mean[num_col].mean(), 2)\n                mean_mean_sum, mean_mean_mean = self._get_average_of_sum_avg_cat_col(table_name, cat_col, num_col)\n                queries = [\n                    f\"\"\"SELECT \"{cat_col}\" FROM \"{table_name}\" GROUP BY \"{cat_col}\" HAVING AVG(\"{num_col}\") &gt;= '{mean_mean_mean}'\"\"\",\n                    f\"\"\"SELECT \"{cat_col}\" FROM \"{table_name}\" GROUP BY \"{cat_col}\" HAVING AVG(\"{num_col}\") &lt;= '{mean_mean_mean}'\"\"\",\n                    f\"\"\"SELECT \"{cat_col}\" FROM \"{table_name}\" GROUP BY \"{cat_col}\" HAVING SUM(\"{num_col}\") &gt;= '{mean_mean_sum}'\"\"\",\n                    f\"\"\"SELECT \"{cat_col}\" FROM \"{table_name}\" GROUP BY \"{cat_col}\" HAVING SUM(\"{num_col}\") &lt;= '{mean_mean_sum}'\"\"\",\n                ]\n\n                questions = [\n                    f'List the \"{cat_col}\" which average \"{num_col}\" is at least {mean_mean_mean} in table \"{table_name}\"',\n                    f'List the \"{cat_col}\" which average \"{num_col}\" is at most {mean_mean_mean} in table \"{table_name}\"',\n\n                    f'List the \"{cat_col}\" which summation of \"{num_col}\" is at least {mean_mean_sum} in table \"{table_name}\"',\n                    f'List the \"{cat_col}\" which summation of \"{num_col}\" is at most {mean_mean_sum} in table \"{table_name}\"',\n                ]\n\n                sql_tags = ['HAVING-AGG-AVG-GR', 'HAVING-AGG-AVG-LS',\n                            'HAVING-AGG-SUM-GR', 'HAVING-AGG-SUM-LS']\n\n                self.append_sql_generated(sql_tags, queries, questions)\n\n    def _get_average_of_count_cat_col(self, table_name, cat_col):\n        \"\"\"\n        Helper method to calculate the average count of rows for each category in a categorical column.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            cat_col (str): The name of the categorical column.\n\n        Returns:\n            int: The average count of rows for each category.\n        \"\"\"\n        # TODO: pandas performs faster when number of tuples is 5e4 or more\n        # SQL query to get the average count for each category\n        inner_query = f'SELECT COUNT(*) AS row_count FROM \"{table_name}\" GROUP BY \"{cat_col}\"'\n        # Run the inner query and get the average of row counts\n        average = self.database.run_query(f'SELECT AVG(row_count) FROM ({inner_query})')[0][0]\n        return int(average)\n\n    def _get_average_of_sum_avg_cat_col(self, table_name, cat_col, num_col):\n        \"\"\"\n        Helper method to calculate the average sum and average of a numerical column for each category in a categorical column.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            cat_col (str): The name of the categorical column.\n            num_col (str): The name of the numerical column.\n\n        Returns:\n            tuple: A tuple containing the average sum and average of the numerical column for each category.\n        \"\"\"\n        # TODO: pandas performs faster when number of tuples is 5e4 or more\n        # SQL queries to get the average sum and average of numerical column for each category\n        inner_query_sum = f'SELECT SUM(\"{num_col}\") AS sum_col FROM \"{table_name}\" GROUP BY \"{cat_col}\"'\n        inner_query_avg = f'SELECT AVG(\"{num_col}\") AS avg_col FROM \"{table_name}\" GROUP BY \"{cat_col}\"'\n        # Run the inner queries and get the average of sums and averages\n        average_sum = self.database.run_query(f'SELECT AVG(sum_col) FROM ({inner_query_sum})')[0][0]\n        average_avg = self.database.run_query(f'SELECT AVG(avg_col) FROM ({inner_query_avg})')[0][0]\n        return round(average_sum, 2), round(average_avg, 2)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.HavingGenerator.__init__","title":"<code>__init__(database, seed=2023)</code>","text":"<p>Initializes the HavingGenerator object.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> required <code>seed</code> <code>int</code> <p>The seed value for randomization. Default is 2023.</p> <code>2023</code> Source code in <code>qatch/sql_generator/having_generator.py</code> <pre><code>def __init__(self, database: SingleDatabase, seed=2023):\n    \"\"\"\n    Initializes the HavingGenerator object.\n\n    Args:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        seed (int): The seed value for randomization. Default is 2023.\n    \"\"\"\n    super().__init__(database, seed)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.HavingGenerator.sql_generate","title":"<code>sql_generate(table_name)</code>","text":"<p>Generate HAVING SQL queries and corresponding questions for categorical and numerical columns.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table in the database.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, list]</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}</p> <p>Examples:</p> <p>Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\" and (i) the average number of rows for each category in \"colors\" is 2 (ii) the mean of the average numbers for each category is 5 (iii) the average sum of numbers for each category is 10:</p> <pre><code>&gt;&gt;&gt; generator = HavingGenerator(database)\n&gt;&gt;&gt; generator._build_having_count(table_name, [\"colors\"], df)\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"HAVING-COUNT-GR\", \"HAVING-COUNT-LS\", \"HAVING-COUNT-EQ\"],\n    \"queries\": [\n        'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING count(*) &gt;= '2'',\n        'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING count(*) &lt;= '2'',\n        'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING count(*) = '2''\n    ],\n    \"questions\": [\n        'Find all the \"colors\" that have at least 2 records in table \"table_name\"',\n        'Find all the \"colors\" that have at most 2 records in table \"table_name\"',\n        'Find all the \"colors\" that have exactly 2 records in table \"table_name\"'\n    ]\n}\n&gt;&gt;&gt; generator._build_having_agg(table_name, [\"colors\"], [\"numbers\"], df)\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"HAVING-AGG-AVG-GR\", \"HAVING-AGG-AVG-LS\", \"HAVING-AGG-SUM-GR\", \"HAVING-AGG-SUM-LS\"],\n    \"queries\": [\n        'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING AVG(\"numbers\") &gt;= '5.0'',\n        'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING AVG(\"numbers\") &lt;= '5.0'',\n        'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING SUM(\"numbers\") &gt;= '10.0'',\n        'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING SUM(\"numbers\") &lt;= '10.0''\n    ],\n    \"questions\": [\n        'List the \"colors\" which average \"numbers\" is at least 5.0 in table \"table_name\"',\n        'List the \"colors\" which average \"numbers\" is at most 5.0 in table \"table_name\"',\n        'List the \"colors\" which summation of \"numbers\" is at least 5.0 in table \"table_name\"',\n        'List the \"colors\" which summation of \"numbers\" is at most 5.0 in table \"table_name\"'\n    ]\n}\n</code></pre> Source code in <code>qatch/sql_generator/having_generator.py</code> <pre><code>def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n    \"\"\"\n    Generate HAVING SQL queries and corresponding questions for categorical and numerical columns.\n\n    Args:\n        table_name (str): The name of the table in the database.\n\n    Returns:\n        dict: A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n\n    Examples:\n        Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"\n        and (i) the average number of rows for each category in \"colors\" is 2\n        (ii) the mean of the average numbers for each category is 5\n        (iii) the average sum of numbers for each category is 10:\n        &gt;&gt;&gt; generator = HavingGenerator(database)\n        &gt;&gt;&gt; generator._build_having_count(table_name, [\"colors\"], df)\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"HAVING-COUNT-GR\", \"HAVING-COUNT-LS\", \"HAVING-COUNT-EQ\"],\n            \"queries\": [\n                'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING count(*) &gt;= '2'',\n                'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING count(*) &lt;= '2'',\n                'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING count(*) = '2''\n            ],\n            \"questions\": [\n                'Find all the \"colors\" that have at least 2 records in table \"table_name\"',\n                'Find all the \"colors\" that have at most 2 records in table \"table_name\"',\n                'Find all the \"colors\" that have exactly 2 records in table \"table_name\"'\n            ]\n        }\n        &gt;&gt;&gt; generator._build_having_agg(table_name, [\"colors\"], [\"numbers\"], df)\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"HAVING-AGG-AVG-GR\", \"HAVING-AGG-AVG-LS\", \"HAVING-AGG-SUM-GR\", \"HAVING-AGG-SUM-LS\"],\n            \"queries\": [\n                'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING AVG(\"numbers\") &gt;= '5.0'',\n                'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING AVG(\"numbers\") &lt;= '5.0'',\n                'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING SUM(\"numbers\") &gt;= '10.0'',\n                'SELECT \"colors\" FROM \"table_name\" GROUP BY \"colors\" HAVING SUM(\"numbers\") &lt;= '10.0''\n            ],\n            \"questions\": [\n                'List the \"colors\" which average \"numbers\" is at least 5.0 in table \"table_name\"',\n                'List the \"colors\" which average \"numbers\" is at most 5.0 in table \"table_name\"',\n                'List the \"colors\" which summation of \"numbers\" is at least 5.0 in table \"table_name\"',\n                'List the \"colors\" which summation of \"numbers\" is at most 5.0 in table \"table_name\"'\n            ]\n        }\n    \"\"\"\n    self.empty_sql_generated()\n    df, cat_cols, num_cols = self._sample_cat_num_cols(table_name)\n    self._build_having_count(table_name, cat_cols, df)\n    self._build_having_agg(table_name, cat_cols, num_cols, df)\n    return self.sql_generated\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.NullGenerator","title":"<code>NullGenerator</code>","text":"<p>             Bases: <code>AbstractSqlGenerator</code></p> <p>A class for generating NULL SQL queries and corresponding questions based on a database table.</p> <p>Attributes:</p> Name Type Description <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> <code>sql_generated</code> <code>dict</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}</p> Source code in <code>qatch/sql_generator/null_generator.py</code> <pre><code>class NullGenerator(AbstractSqlGenerator):\n    \"\"\"\n    A class for generating NULL SQL queries and corresponding questions based on a database table.\n\n    Attributes:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        sql_generated (dict): A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n    \"\"\"\n\n    def __init__(self, database: SingleDatabase, seed=2023):\n        \"\"\"\n        Initializes the NullGenerator object.\n\n        Args:\n            database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n            seed (int): The seed value for randomization. Default is 2023.\n        \"\"\"\n        super().__init__(database, seed)\n\n    def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n        \"\"\"\n        Generates NULL queries and corresponding questions.\n\n        Args:\n            table_name (str): The name of the table in the database.\n\n        Returns:\n            dict: A dictionary containing generated SQL tags, queries, and questions.\n                Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n\n        Examples:\n            Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" with 10 NULL values:\n            &gt;&gt;&gt; generator = NullGenerator(database)\n            &gt;&gt;&gt; generator._build_null_count('table_name', ['colors'])\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": ['NULL-COUNT'],\n                \"queries\": ['SELECT COUNT(*) FROM \"table_name\" WHERE \"colors\" IS NULL'],\n                \"questions\": ['Count the rows where the values of \"colors\" are missing in table \"table_name\"']\n            }\n            &gt;&gt;&gt; generator._build_not_null_count('table_name', ['colors'])\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": ['NOT-NULL-COUNT'],\n                \"queries\": ['SELECT COUNT(*) FROM \"table_name\" WHERE \"colors\" IS NOT NULL'],\n                \"questions\": ['Count the rows where the values of \"colors\" are not missing in table \"table_name\"']\n            }\n        \"\"\"\n        self.empty_sql_generated()\n        null_cols = self._get_null_cols(table_name)\n        self._build_null_count(table_name, null_cols)\n        self._build_not_null_count(table_name, null_cols)\n        # self._build_null_with_no_null_col(table_name)\n        return self.sql_generated\n\n    def _build_null_count(self, table_name: str, null_cols: list[str]):\n        \"\"\"\n        Build SQL queries and questions for counting rows with NULL values in specified columns.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            null_cols (list): List of column names with NULL values.\n        \"\"\"\n        queries = [f'SELECT COUNT(*) FROM \"{table_name}\" WHERE \"{col}\" IS NULL'\n                   for col in null_cols]\n\n        questions = [f'Count the rows where the values of \"{col}\" are missing in table \"{table_name}\"'\n                     for col in null_cols]\n\n        sql_tags = ['NULL-COUNT'] * len(queries)\n        self.append_sql_generated(sql_tags, queries, questions)\n\n    def _build_not_null_count(self, table_name, null_cols: list[str]):\n        \"\"\"\n        Build SQL queries and questions for counting rows with non-NULL values in specified columns.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            null_cols (list): List of column names with NULL values.\n        \"\"\"\n        queries = [f'SELECT COUNT(*) FROM \"{table_name}\" WHERE \"{col}\" IS NOT NULL'\n                   for col in null_cols]\n\n        questions = [f'Count the rows where the values of \"{col}\" are not missing in table \"{table_name}\"'\n                     for col in null_cols]\n\n        sql_tags = ['NOT-NULL-COUNT'] * len(queries)\n        self.append_sql_generated(sql_tags, queries, questions)\n\n    def _get_null_cols(self, table_name: str, sample=2):\n        \"\"\"\n        Randomly select columns with NULL values from the given table for generating queries.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            sample (int, optional): Number of columns to sample. Default is 2.\n\n        Returns:\n            list: List of column names with NULL values.\n        \"\"\"\n        df, _, _ = self._sample_cat_num_cols(table_name)\n        mask = df.isnull().any()\n        cols = list(df.columns[mask])\n        return random.sample(cols, sample) if len(cols) &gt;= sample else cols\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.NullGenerator.__init__","title":"<code>__init__(database, seed=2023)</code>","text":"<p>Initializes the NullGenerator object.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> required <code>seed</code> <code>int</code> <p>The seed value for randomization. Default is 2023.</p> <code>2023</code> Source code in <code>qatch/sql_generator/null_generator.py</code> <pre><code>def __init__(self, database: SingleDatabase, seed=2023):\n    \"\"\"\n    Initializes the NullGenerator object.\n\n    Args:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        seed (int): The seed value for randomization. Default is 2023.\n    \"\"\"\n    super().__init__(database, seed)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.NullGenerator.sql_generate","title":"<code>sql_generate(table_name)</code>","text":"<p>Generates NULL queries and corresponding questions.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table in the database.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, list]</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}</p> <p>Examples:</p> <p>Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" with 10 NULL values:</p> <pre><code>&gt;&gt;&gt; generator = NullGenerator(database)\n&gt;&gt;&gt; generator._build_null_count('table_name', ['colors'])\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": ['NULL-COUNT'],\n    \"queries\": ['SELECT COUNT(*) FROM \"table_name\" WHERE \"colors\" IS NULL'],\n    \"questions\": ['Count the rows where the values of \"colors\" are missing in table \"table_name\"']\n}\n&gt;&gt;&gt; generator._build_not_null_count('table_name', ['colors'])\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": ['NOT-NULL-COUNT'],\n    \"queries\": ['SELECT COUNT(*) FROM \"table_name\" WHERE \"colors\" IS NOT NULL'],\n    \"questions\": ['Count the rows where the values of \"colors\" are not missing in table \"table_name\"']\n}\n</code></pre> Source code in <code>qatch/sql_generator/null_generator.py</code> <pre><code>def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n    \"\"\"\n    Generates NULL queries and corresponding questions.\n\n    Args:\n        table_name (str): The name of the table in the database.\n\n    Returns:\n        dict: A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n\n    Examples:\n        Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" with 10 NULL values:\n        &gt;&gt;&gt; generator = NullGenerator(database)\n        &gt;&gt;&gt; generator._build_null_count('table_name', ['colors'])\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": ['NULL-COUNT'],\n            \"queries\": ['SELECT COUNT(*) FROM \"table_name\" WHERE \"colors\" IS NULL'],\n            \"questions\": ['Count the rows where the values of \"colors\" are missing in table \"table_name\"']\n        }\n        &gt;&gt;&gt; generator._build_not_null_count('table_name', ['colors'])\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": ['NOT-NULL-COUNT'],\n            \"queries\": ['SELECT COUNT(*) FROM \"table_name\" WHERE \"colors\" IS NOT NULL'],\n            \"questions\": ['Count the rows where the values of \"colors\" are not missing in table \"table_name\"']\n        }\n    \"\"\"\n    self.empty_sql_generated()\n    null_cols = self._get_null_cols(table_name)\n    self._build_null_count(table_name, null_cols)\n    self._build_not_null_count(table_name, null_cols)\n    # self._build_null_with_no_null_col(table_name)\n    return self.sql_generated\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.OrderByGenerator","title":"<code>OrderByGenerator</code>","text":"<p>             Bases: <code>AbstractSqlGenerator</code></p> <p>A class for generating ORDER BY SQL queries and corresponding questions based on a database table.</p> <p>Attributes:</p> Name Type Description <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> <code>sql_generated</code> <code>dict</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}</p> Source code in <code>qatch/sql_generator/orderby_generator.py</code> <pre><code>class OrderByGenerator(AbstractSqlGenerator):\n    \"\"\"\n    A class for generating ORDER BY SQL queries and corresponding questions based on a database table.\n\n    Attributes:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        sql_generated (dict): A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n    \"\"\"\n\n    def __int__(self, database: SingleDatabase, *args, **kwargs):\n        \"\"\"\n        Initializes the OrderByGenerator object.\n\n        Args:\n            database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n        \"\"\"\n        super().__init__(database, *args, **kwargs)\n\n    def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n        \"\"\"\n        Generate ORDER BY queries and corresponding questions based on the specified table.\n\n        Args:\n            table_name (str): The name of the table in the database.\n\n        Returns:\n            dict: A dictionary containing generated SQL tags, queries, and questions.\n                Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n\n        Examples:\n            Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"\n            &gt;&gt;&gt; generator = OrderByGenerator(database)\n            &gt;&gt;&gt; generator._generate_order_asc(\"table_name\", [\"colors\", \"numbers\"])\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"ORDERBY-SINGLE\", \"ORDERBY-SINGLE\"],\n                \"queries\": [\n                    'SELECT * FROM \"table_name\" ORDER BY \"colors\" ASC',\n                    'SELECT * FROM \"table_name\" ORDER BY \"numbers\" ASC'\n                ],\n                \"questions\": [\n                    'Show all data ordered by \"colors\" in ascending order for the table \"table_name\"',\n                    'Show all data ordered by \"numbers\" in ascending order for the table \"table_name\"'\n                ]\n            }\n            &gt;&gt;&gt; generator._generate_order_desc(\"table_name\", [\"colors\", \"numbers\"])\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"ORDERBY-SINGLE\", \"ORDERBY-SINGLE\"],\n                \"queries\": [\n                    'SELECT * FROM \"table_name\" ORDER BY \"colors\" DESC',\n                    'SELECT * FROM \"table_name\" ORDER BY \"numbers\" DESC'\n                ],\n                \"questions\": [\n                    'Show all data ordered by \"colors\" in descending order for the table \"table_name\"',\n                    'Show all data ordered by \"numbers\" in descending order for the table \"table_name\"'\n                ]\n            }\n            &gt;&gt;&gt; generator._generate_order_asc_project(\"table_name\", [\"colors\", \"numbers\"])\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"ORDERBY-PROJECT\", \"ORDERBY-PROJECT\"],\n                \"queries\": [\n                    'SELECT \"colors\" FROM \"table_name\" ORDER BY \"colors\" ASC',\n                    'SELECT \"numbers\" FROM \"table_name\" ORDER BY \"numbers\" ASC'\n                ],\n                \"questions\": [\n                    'Project the \"colors\" ordered in ascending order for the table \"table_name\"',\n                    'Project the \"numbers\" ordered in ascending order for the table \"table_name\"'\n                ]\n            }\n            &gt;&gt;&gt; generator._generate_order_desc_project(\"table_name\", [\"colors\", \"numbers\"])\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"ORDERBY-PROJECT\", \"ORDERBY-PROJECT\"],\n                \"queries\": [\n                    'SELECT \"colors\" FROM \"table_name\" ORDER BY \"colors\" DESC',\n                    'SELECT \"numbers\" FROM \"table_name\" ORDER BY \"numbers\" DESC'\n                ],\n                \"questions\": [\n                    'Project the \"colors\" ordered in descending order for the table \"table_name\"',\n                    'Project the \"numbers\" ordered in descending order for the table \"table_name\"'\n                ]\n            }\n        \"\"\"\n        self.empty_sql_generated()\n        columns = self.database.get_schema_given(table_name).name.tolist()\n        self._generate_order_asc(table_name, columns)\n        self._generate_order_desc(table_name, columns)\n\n        self._generate_order_asc_project(table_name, columns)\n        self._generate_order_desc_project(table_name, columns)\n        return self.sql_generated\n\n    def _generate_order_asc(self, table_name: str, columns: list[str]):\n        \"\"\"\n        Generates SQL queries and questions for ordering data in ascending order for each column.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            columns (list): List of column names.\n        \"\"\"\n        queries = [f'SELECT * FROM \"{table_name}\" ORDER BY \"{col}\" ASC'\n                   for col in columns]\n\n        questions = [\n            f'Show all data ordered by \"{col}\" in ascending order for the table \"{table_name}\"'\n            for col in columns\n        ]\n        sql_tags = ['ORDERBY-SINGLE'] * len(queries)\n        self.append_sql_generated(sql_tags, queries, questions)\n\n    def _generate_order_desc(self, table_name: str, columns: list[str]):\n        \"\"\"\n        Generates SQL queries and questions for ordering data in descending order for each column.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            columns (list): List of column names.\n        \"\"\"\n        queries = [f'SELECT * FROM \"{table_name}\" ORDER BY \"{col}\" DESC'\n                   for col in columns]\n\n        questions = [\n            f'Show all data ordered by \"{col}\" in descending order for the table \"{table_name}\"'\n            for col in columns\n        ]\n        sql_tags = ['ORDERBY-SINGLE'] * len(queries)\n        self.append_sql_generated(sql_tags, queries, questions)\n\n    def _generate_order_asc_project(self, table_name: str, columns: list[str]):\n        \"\"\"\n        Generates SQL queries and questions for projecting a single column and ordering it in ascending order.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            columns (list): List of column names.\n        \"\"\"\n        queries = [f'SELECT \"{col}\" FROM \"{table_name}\" ORDER BY \"{col}\" ASC'\n                   for col in columns]\n\n        questions = [\n            f'Project the \"{col}\" ordered in ascending order for the table {table_name}'\n            for col in columns\n        ]\n        sql_tags = ['ORDERBY-PROJECT'] * len(queries)\n        self.append_sql_generated(sql_tags, queries, questions)\n\n    def _generate_order_desc_project(self, table_name: str, columns: list[str]):\n        \"\"\"\n        Generates SQL queries and questions for projecting a single column and ordering it in descending order.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            columns (list): List of column names.\n        \"\"\"\n        queries = [f'SELECT \"{col}\" FROM \"{table_name}\" ORDER BY \"{col}\" DESC'\n                   for col in columns]\n\n        questions = [\n            f'Project the \"{col}\" ordered in descending order for the table {table_name}'\n            for col in columns\n        ]\n        sql_tags = ['ORDERBY-PROJECT'] * len(queries)\n        self.append_sql_generated(sql_tags, queries, questions)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.OrderByGenerator.__int__","title":"<code>__int__(database, *args, **kwargs)</code>","text":"<p>Initializes the OrderByGenerator object.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> required <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> Source code in <code>qatch/sql_generator/orderby_generator.py</code> <pre><code>def __int__(self, database: SingleDatabase, *args, **kwargs):\n    \"\"\"\n    Initializes the OrderByGenerator object.\n\n    Args:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n    \"\"\"\n    super().__init__(database, *args, **kwargs)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.OrderByGenerator.sql_generate","title":"<code>sql_generate(table_name)</code>","text":"<p>Generate ORDER BY queries and corresponding questions based on the specified table.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table in the database.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, list]</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}</p> <p>Examples:</p> <p>Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"</p> <pre><code>&gt;&gt;&gt; generator = OrderByGenerator(database)\n&gt;&gt;&gt; generator._generate_order_asc(\"table_name\", [\"colors\", \"numbers\"])\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"ORDERBY-SINGLE\", \"ORDERBY-SINGLE\"],\n    \"queries\": [\n        'SELECT * FROM \"table_name\" ORDER BY \"colors\" ASC',\n        'SELECT * FROM \"table_name\" ORDER BY \"numbers\" ASC'\n    ],\n    \"questions\": [\n        'Show all data ordered by \"colors\" in ascending order for the table \"table_name\"',\n        'Show all data ordered by \"numbers\" in ascending order for the table \"table_name\"'\n    ]\n}\n&gt;&gt;&gt; generator._generate_order_desc(\"table_name\", [\"colors\", \"numbers\"])\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"ORDERBY-SINGLE\", \"ORDERBY-SINGLE\"],\n    \"queries\": [\n        'SELECT * FROM \"table_name\" ORDER BY \"colors\" DESC',\n        'SELECT * FROM \"table_name\" ORDER BY \"numbers\" DESC'\n    ],\n    \"questions\": [\n        'Show all data ordered by \"colors\" in descending order for the table \"table_name\"',\n        'Show all data ordered by \"numbers\" in descending order for the table \"table_name\"'\n    ]\n}\n&gt;&gt;&gt; generator._generate_order_asc_project(\"table_name\", [\"colors\", \"numbers\"])\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"ORDERBY-PROJECT\", \"ORDERBY-PROJECT\"],\n    \"queries\": [\n        'SELECT \"colors\" FROM \"table_name\" ORDER BY \"colors\" ASC',\n        'SELECT \"numbers\" FROM \"table_name\" ORDER BY \"numbers\" ASC'\n    ],\n    \"questions\": [\n        'Project the \"colors\" ordered in ascending order for the table \"table_name\"',\n        'Project the \"numbers\" ordered in ascending order for the table \"table_name\"'\n    ]\n}\n&gt;&gt;&gt; generator._generate_order_desc_project(\"table_name\", [\"colors\", \"numbers\"])\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"ORDERBY-PROJECT\", \"ORDERBY-PROJECT\"],\n    \"queries\": [\n        'SELECT \"colors\" FROM \"table_name\" ORDER BY \"colors\" DESC',\n        'SELECT \"numbers\" FROM \"table_name\" ORDER BY \"numbers\" DESC'\n    ],\n    \"questions\": [\n        'Project the \"colors\" ordered in descending order for the table \"table_name\"',\n        'Project the \"numbers\" ordered in descending order for the table \"table_name\"'\n    ]\n}\n</code></pre> Source code in <code>qatch/sql_generator/orderby_generator.py</code> <pre><code>def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n    \"\"\"\n    Generate ORDER BY queries and corresponding questions based on the specified table.\n\n    Args:\n        table_name (str): The name of the table in the database.\n\n    Returns:\n        dict: A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n\n    Examples:\n        Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"\n        &gt;&gt;&gt; generator = OrderByGenerator(database)\n        &gt;&gt;&gt; generator._generate_order_asc(\"table_name\", [\"colors\", \"numbers\"])\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"ORDERBY-SINGLE\", \"ORDERBY-SINGLE\"],\n            \"queries\": [\n                'SELECT * FROM \"table_name\" ORDER BY \"colors\" ASC',\n                'SELECT * FROM \"table_name\" ORDER BY \"numbers\" ASC'\n            ],\n            \"questions\": [\n                'Show all data ordered by \"colors\" in ascending order for the table \"table_name\"',\n                'Show all data ordered by \"numbers\" in ascending order for the table \"table_name\"'\n            ]\n        }\n        &gt;&gt;&gt; generator._generate_order_desc(\"table_name\", [\"colors\", \"numbers\"])\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"ORDERBY-SINGLE\", \"ORDERBY-SINGLE\"],\n            \"queries\": [\n                'SELECT * FROM \"table_name\" ORDER BY \"colors\" DESC',\n                'SELECT * FROM \"table_name\" ORDER BY \"numbers\" DESC'\n            ],\n            \"questions\": [\n                'Show all data ordered by \"colors\" in descending order for the table \"table_name\"',\n                'Show all data ordered by \"numbers\" in descending order for the table \"table_name\"'\n            ]\n        }\n        &gt;&gt;&gt; generator._generate_order_asc_project(\"table_name\", [\"colors\", \"numbers\"])\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"ORDERBY-PROJECT\", \"ORDERBY-PROJECT\"],\n            \"queries\": [\n                'SELECT \"colors\" FROM \"table_name\" ORDER BY \"colors\" ASC',\n                'SELECT \"numbers\" FROM \"table_name\" ORDER BY \"numbers\" ASC'\n            ],\n            \"questions\": [\n                'Project the \"colors\" ordered in ascending order for the table \"table_name\"',\n                'Project the \"numbers\" ordered in ascending order for the table \"table_name\"'\n            ]\n        }\n        &gt;&gt;&gt; generator._generate_order_desc_project(\"table_name\", [\"colors\", \"numbers\"])\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"ORDERBY-PROJECT\", \"ORDERBY-PROJECT\"],\n            \"queries\": [\n                'SELECT \"colors\" FROM \"table_name\" ORDER BY \"colors\" DESC',\n                'SELECT \"numbers\" FROM \"table_name\" ORDER BY \"numbers\" DESC'\n            ],\n            \"questions\": [\n                'Project the \"colors\" ordered in descending order for the table \"table_name\"',\n                'Project the \"numbers\" ordered in descending order for the table \"table_name\"'\n            ]\n        }\n    \"\"\"\n    self.empty_sql_generated()\n    columns = self.database.get_schema_given(table_name).name.tolist()\n    self._generate_order_asc(table_name, columns)\n    self._generate_order_desc(table_name, columns)\n\n    self._generate_order_asc_project(table_name, columns)\n    self._generate_order_desc_project(table_name, columns)\n    return self.sql_generated\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.SelectGenerator","title":"<code>SelectGenerator</code>","text":"<p>             Bases: <code>AbstractSqlGenerator</code></p> <p>A class for generating SELECT SQL queries and corresponding questions based on a database table.</p> <p>Attributes:</p> Name Type Description <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> <code>sql_generated</code> <code>dict</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}</p> Source code in <code>qatch/sql_generator/select_generator.py</code> <pre><code>class SelectGenerator(AbstractSqlGenerator):\n    \"\"\"\n    A class for generating SELECT SQL queries and corresponding questions based on a database table.\n\n    Attributes:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        sql_generated (dict): A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n    \"\"\"\n\n    def __int__(self, database: SingleDatabase, *args, **kwargs):\n        \"\"\"\n        Initializes the SelectGenerator object.\n\n        Args:\n            database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n        \"\"\"\n        super().__init__(database, *args, **kwargs)\n\n    def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n        \"\"\"\n        Generate SQL tags, queries, and questions based on the specified table.\n\n        Args:\n            table_name (str): The name of the table in the database.\n\n        Returns:\n            dict: A dictionary containing generated SQL tags, queries, and questions.\n                Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n\n        Examples:\n            Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"name\", \"colors\" and \"numbers\":\n            &gt;&gt;&gt; generator = SelectGenerator(database)\n            &gt;&gt;&gt; generator._select_all_table(\"table_name\")\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"SELECT-ALL\"],\n                \"queries\": ['SELECT * FROM \"table_name\"'],\n                \"questions\": [\"Show all the rows in the table table_name\"]\n            }\n            &gt;&gt;&gt; generator._select_add_col(\"table_name\")\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"SELECT-ADD-COL\", \"SELECT-ADD-COL\", \"SELECT-ADD-COL\"],\n                \"queries\": ['SELECT \"colors\" FROM \"table_name\"',\n                            'SELECT \"colors\", \"numbers\" FROM \"table_name\"'\n                            'SELECT \"colors\", \"numbers\", \"name\" FROM \"table_name\"'],\n                \"questions\": [\"Show all colors in the table table_name\",\n                              \"Show all colors, numbers in the table table_name\"\n                              \"Show all colors, numbers, name in the table table_name\"]\n            }\n            &gt;&gt;&gt; generator._select_random_col(\"table_name\")\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"SELECT-RANDOM-COL\", \"SELECT-RANDOM-COL\"],\n                \"queries\": ['SELECT \"colors\" FROM \"table_name\"',\n                            'SELECT \"name\", \"numbers\" FROM \"table_name\"',\n                            'SELECT \"numbers\", \"colors\", \"name\" FROM \"table_name\"'],\n                \"questions\": [\"Show all colors in the table table_name\",\n                              \"Show all name, numbers in the table table_name\",\n                              \"Show all numbers, colors, name in the table table_name\"]\n            }\n\n        \"\"\"\n        self.empty_sql_generated()\n        self._select_all_table(table_name)\n        self._select_add_col(table_name)\n        self._select_random_col(table_name)\n        return self.sql_generated\n\n    def _select_all_table(self, table_name: str):\n        \"\"\"\n        Generate the SQL query and question for selecting all rows in the table.\n\n        Args:\n            table_name (str): The name of the table in the database.\n        \"\"\"\n        sql_tag = ['SELECT-ALL']\n        query = [f'SELECT * FROM \"{table_name}\"']\n        question = [f\"Show all the rows in the table {table_name}\"]\n        self.append_sql_generated(sql_tags=sql_tag, queries=query, questions=question)\n\n    def _select_add_col(self, table_name: str):\n        \"\"\"\n        Generate the SQL query and question for selecting increasingly more columns in the table.\n\n        Args:\n            table_name (str): The name of the table in the database.\n        \"\"\"\n        columns = self.database.get_schema_given(table_name).name.tolist()\n        comb_cols_add = self._comb_add_columns(columns)\n\n        questions = self._build_questions(comb_cols_add, table_name)\n        queries = self._build_queries(comb_cols_add, table_name)\n\n        self.append_sql_generated(sql_tags=['SELECT-ADD-COL'] * len(comb_cols_add),\n                                  queries=queries, questions=questions)\n\n    def _select_random_col(self, table_name: str):\n        \"\"\"\n        Generate the SQL query and question for selecting random columns in the table.\n\n        Args:\n            table_name (str): The name of the table in the database.\n        \"\"\"\n        columns = self.database.get_schema_given(table_name).name.tolist()\n        comb_cols_rand = self._comb_random(columns)\n\n        questions = self._build_questions(comb_cols_rand, table_name)\n        queries = self._build_queries(comb_cols_rand, table_name)\n\n        self.append_sql_generated(sql_tags=['SELECT-RANDOM-COL'] * len(comb_cols_rand),\n                                  queries=queries, questions=questions)\n\n    def _build_questions(self, combinations: list[list[str]], table_name) -&gt; list[str]:\n        \"\"\"\n        Builds questions corresponding to the given column combinations and table name.\n\n        Args:\n            combinations (list[list[str]]): List of column combinations.\n            table_name (str): The name of the table in the database.\n\n        Returns:\n            list[str]: A list of questions corresponding to the column combinations.\n        \"\"\"\n        return [f'Show all {self._get_col_comb_str(comb)} in the table {table_name}'\n                for comb in combinations]\n\n    def _build_queries(self, combinations: list[str], table_name: str) -&gt; list[str]:\n        \"\"\"\n        Builds SQL queries corresponding to the given column combinations and table name.\n\n        Args:\n            combinations (list[list[str]]): List of column combinations.\n            table_name (str): The name of the table in the database.\n\n        Returns:\n            list[str]: A list of SQL queries corresponding to the column combinations.\n        \"\"\"\n        return [f'SELECT {self._get_col_comb_str(comb)} FROM \"{table_name}\"'\n                for comb in combinations]\n\n    @staticmethod\n    def _comb_add_columns(columns: list[str]) -&gt; list[list[str]]:\n        \"\"\"\n        Generates column combinations by incrementally adding columns to the query.\n\n        Args:\n            columns (list[str]): List of column names.\n\n        Returns:\n            list[list[str]]: A list of column combinations.\n        \"\"\"\n        return [columns[:i] for i in range(1, len(columns))]\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.SelectGenerator.__int__","title":"<code>__int__(database, *args, **kwargs)</code>","text":"<p>Initializes the SelectGenerator object.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> required <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> Source code in <code>qatch/sql_generator/select_generator.py</code> <pre><code>def __int__(self, database: SingleDatabase, *args, **kwargs):\n    \"\"\"\n    Initializes the SelectGenerator object.\n\n    Args:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n    \"\"\"\n    super().__init__(database, *args, **kwargs)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.SelectGenerator.sql_generate","title":"<code>sql_generate(table_name)</code>","text":"<p>Generate SQL tags, queries, and questions based on the specified table.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table in the database.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, list]</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}</p> <p>Examples:</p> <p>Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"name\", \"colors\" and \"numbers\":</p> <pre><code>&gt;&gt;&gt; generator = SelectGenerator(database)\n&gt;&gt;&gt; generator._select_all_table(\"table_name\")\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"SELECT-ALL\"],\n    \"queries\": ['SELECT * FROM \"table_name\"'],\n    \"questions\": [\"Show all the rows in the table table_name\"]\n}\n&gt;&gt;&gt; generator._select_add_col(\"table_name\")\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"SELECT-ADD-COL\", \"SELECT-ADD-COL\", \"SELECT-ADD-COL\"],\n    \"queries\": ['SELECT \"colors\" FROM \"table_name\"',\n                'SELECT \"colors\", \"numbers\" FROM \"table_name\"'\n                'SELECT \"colors\", \"numbers\", \"name\" FROM \"table_name\"'],\n    \"questions\": [\"Show all colors in the table table_name\",\n                  \"Show all colors, numbers in the table table_name\"\n                  \"Show all colors, numbers, name in the table table_name\"]\n}\n&gt;&gt;&gt; generator._select_random_col(\"table_name\")\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"SELECT-RANDOM-COL\", \"SELECT-RANDOM-COL\"],\n    \"queries\": ['SELECT \"colors\" FROM \"table_name\"',\n                'SELECT \"name\", \"numbers\" FROM \"table_name\"',\n                'SELECT \"numbers\", \"colors\", \"name\" FROM \"table_name\"'],\n    \"questions\": [\"Show all colors in the table table_name\",\n                  \"Show all name, numbers in the table table_name\",\n                  \"Show all numbers, colors, name in the table table_name\"]\n}\n</code></pre> Source code in <code>qatch/sql_generator/select_generator.py</code> <pre><code>def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n    \"\"\"\n    Generate SQL tags, queries, and questions based on the specified table.\n\n    Args:\n        table_name (str): The name of the table in the database.\n\n    Returns:\n        dict: A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n\n    Examples:\n        Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"name\", \"colors\" and \"numbers\":\n        &gt;&gt;&gt; generator = SelectGenerator(database)\n        &gt;&gt;&gt; generator._select_all_table(\"table_name\")\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"SELECT-ALL\"],\n            \"queries\": ['SELECT * FROM \"table_name\"'],\n            \"questions\": [\"Show all the rows in the table table_name\"]\n        }\n        &gt;&gt;&gt; generator._select_add_col(\"table_name\")\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"SELECT-ADD-COL\", \"SELECT-ADD-COL\", \"SELECT-ADD-COL\"],\n            \"queries\": ['SELECT \"colors\" FROM \"table_name\"',\n                        'SELECT \"colors\", \"numbers\" FROM \"table_name\"'\n                        'SELECT \"colors\", \"numbers\", \"name\" FROM \"table_name\"'],\n            \"questions\": [\"Show all colors in the table table_name\",\n                          \"Show all colors, numbers in the table table_name\"\n                          \"Show all colors, numbers, name in the table table_name\"]\n        }\n        &gt;&gt;&gt; generator._select_random_col(\"table_name\")\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"SELECT-RANDOM-COL\", \"SELECT-RANDOM-COL\"],\n            \"queries\": ['SELECT \"colors\" FROM \"table_name\"',\n                        'SELECT \"name\", \"numbers\" FROM \"table_name\"',\n                        'SELECT \"numbers\", \"colors\", \"name\" FROM \"table_name\"'],\n            \"questions\": [\"Show all colors in the table table_name\",\n                          \"Show all name, numbers in the table table_name\",\n                          \"Show all numbers, colors, name in the table table_name\"]\n        }\n\n    \"\"\"\n    self.empty_sql_generated()\n    self._select_all_table(table_name)\n    self._select_add_col(table_name)\n    self._select_random_col(table_name)\n    return self.sql_generated\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.SimpleAggGenerator","title":"<code>SimpleAggGenerator</code>","text":"<p>             Bases: <code>AbstractSqlGenerator</code></p> <p>A class for generating Simple Aggregation queries and corresponding questions based on a database table.</p> <p>Attributes:</p> Name Type Description <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> <code>sql_generated</code> <code>dict</code> <p>A dictionary containing generated SQL tags, queries, and questions. Format: {\"sql_tags\": List[str], \"queries\": List[str], \"questions\": List[str]}</p> Source code in <code>qatch/sql_generator/simple_agg_generator.py</code> <pre><code>class SimpleAggGenerator(AbstractSqlGenerator):\n    \"\"\"\n    A class for generating Simple Aggregation queries and corresponding questions based on a database table.\n\n    Attributes:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        sql_generated (dict): A dictionary containing generated SQL tags, queries, and questions.\n            Format: {\"sql_tags\": List[str], \"queries\": List[str], \"questions\": List[str]}\n    \"\"\"\n\n    def __init__(self, database: SingleDatabase, *args, **kwargs):\n        \"\"\"\n        Initializes a SimpleAggGenerator object.\n\n        Args:\n            database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        \"\"\"\n        super().__init__(database, *args, **kwargs)\n\n    def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n        \"\"\"\n        Generates Simple Aggregation SQL queries and corresponding questions for the specified table.\n\n        Args:\n            table_name (str): The name of the table in the database.\n\n        Returns:\n            dict: A dictionary containing generated SQL tags, queries, and questions.\n                  Format: {\"sql_tags\": List[str], \"queries\": List[str], \"questions\": List[str]}\n\n        Examples:\n            Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"\n            &gt;&gt;&gt; generator = SimpleAggGenerator(database)\n            &gt;&gt;&gt; generator._build_count_cat(\"table_name\", [\"colors\"])\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"SIMPLE-AGG-COUNT\", \"SIMPLE-AGG-COUNT-DISTINCT\"],\n                \"queries\": [\n                    'SELECT COUNT(*) FROM \"table_name\"',\n                    'SELECT COUNT(DISTINCT\"colors\") FROM \"table_name\"'\n                ],\n                \"questions\": [\n                    'Count the records in table \"table_name\"?',\n                    'How many different \"colors\" are in table \"table_name\"?'\n                ]\n            }\n            &gt;&gt;&gt; generator._build_count_agg(\"table_name\", [\"numbers\"])\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"SIMPLE-AGG-MAX\", \"SIMPLE-AGG-MIN\", \"SIMPLE-AGG-AVG\"],\n                \"queries\": [\n                    'SELECT MAX(\"numbers\") FROM \"table_name\"',\n                    'SELECT MIN(\"numbers\") FROM \"table_name\"',\n                    'SELECT AVG(\"numbers\") FROM \"table_name\"'\n                ],\n                \"questions\": [\n                    'Find the maximum \"numbers\" for the table \"table_name\"',\n                    'Find the minimum \"numbers\" for the table \"table_name\"',\n                    'Find the average \"numbers\" for the table \"table_name\"'\n                ]\n            }\n        \"\"\"\n        self.empty_sql_generated()\n        _, cat_cols, num_cols = self._sample_cat_num_cols(table_name)\n        self._build_count_cat(table_name, cat_cols)\n        self._build_count_agg(table_name, num_cols)\n        return self.sql_generated\n\n    def _build_count_cat(self, table_name, cat_cols):\n        \"\"\"\n        Generates COUNT SQL queries and questions for categorical columns.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            cat_cols (List[str]): List of categorical columns in the table.\n        \"\"\"\n\n        queries = [f'SELECT COUNT(*) FROM \"{table_name}\"']\n        questions = [f'Count the records in table \"{table_name}\"?']\n        sql_tags = ['SIMPLE-AGG-COUNT']\n\n        for cat_col in cat_cols:\n            queries += [f'SELECT COUNT(DISTINCT\"{cat_col}\") FROM \"{table_name}\"']\n            questions += [f'How many different \"{cat_col}\" are in table \"{table_name}\"?']\n            sql_tags += ['SIMPLE-AGG-COUNT-DISTINCT']\n\n        self.append_sql_generated(sql_tags, queries, questions)\n\n    def _build_count_agg(self, table_name, num_cols):\n        \"\"\"\n        Generates MAX, MIN, and AVG SQL queries and questions for numerical columns.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            num_cols (List[str]): List of numerical columns in the table.\n        \"\"\"\n        for num_col in num_cols:\n            queries = [\n                f'SELECT MAX(\"{num_col}\") FROM \"{table_name}\"',\n                f'SELECT MIN(\"{num_col}\") FROM \"{table_name}\"',\n                f'SELECT AVG(\"{num_col}\") FROM \"{table_name}\"'\n            ]\n            questions = [\n                f'Find the maximum \"{num_col}\" for the table \"{table_name}\"',\n                f'Find the minimum \"{num_col}\" for the table \"{table_name}\"',\n                f'Find the average \"{num_col}\" for the table \"{table_name}\"'\n            ]\n            sql_tags = ['SIMPLE-AGG-MAX', 'SIMPLE-AGG-MIN', 'SIMPLE-AGG-AVG']\n            self.append_sql_generated(sql_tags, queries, questions)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.SimpleAggGenerator.__init__","title":"<code>__init__(database, *args, **kwargs)</code>","text":"<p>Initializes a SimpleAggGenerator object.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> required Source code in <code>qatch/sql_generator/simple_agg_generator.py</code> <pre><code>def __init__(self, database: SingleDatabase, *args, **kwargs):\n    \"\"\"\n    Initializes a SimpleAggGenerator object.\n\n    Args:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n    \"\"\"\n    super().__init__(database, *args, **kwargs)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.SimpleAggGenerator.sql_generate","title":"<code>sql_generate(table_name)</code>","text":"<p>Generates Simple Aggregation SQL queries and corresponding questions for the specified table.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table in the database.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, list]</code> <p>A dictionary containing generated SQL tags, queries, and questions.   Format: {\"sql_tags\": List[str], \"queries\": List[str], \"questions\": List[str]}</p> <p>Examples:</p> <p>Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"</p> <pre><code>&gt;&gt;&gt; generator = SimpleAggGenerator(database)\n&gt;&gt;&gt; generator._build_count_cat(\"table_name\", [\"colors\"])\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"SIMPLE-AGG-COUNT\", \"SIMPLE-AGG-COUNT-DISTINCT\"],\n    \"queries\": [\n        'SELECT COUNT(*) FROM \"table_name\"',\n        'SELECT COUNT(DISTINCT\"colors\") FROM \"table_name\"'\n    ],\n    \"questions\": [\n        'Count the records in table \"table_name\"?',\n        'How many different \"colors\" are in table \"table_name\"?'\n    ]\n}\n&gt;&gt;&gt; generator._build_count_agg(\"table_name\", [\"numbers\"])\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"SIMPLE-AGG-MAX\", \"SIMPLE-AGG-MIN\", \"SIMPLE-AGG-AVG\"],\n    \"queries\": [\n        'SELECT MAX(\"numbers\") FROM \"table_name\"',\n        'SELECT MIN(\"numbers\") FROM \"table_name\"',\n        'SELECT AVG(\"numbers\") FROM \"table_name\"'\n    ],\n    \"questions\": [\n        'Find the maximum \"numbers\" for the table \"table_name\"',\n        'Find the minimum \"numbers\" for the table \"table_name\"',\n        'Find the average \"numbers\" for the table \"table_name\"'\n    ]\n}\n</code></pre> Source code in <code>qatch/sql_generator/simple_agg_generator.py</code> <pre><code>def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n    \"\"\"\n    Generates Simple Aggregation SQL queries and corresponding questions for the specified table.\n\n    Args:\n        table_name (str): The name of the table in the database.\n\n    Returns:\n        dict: A dictionary containing generated SQL tags, queries, and questions.\n              Format: {\"sql_tags\": List[str], \"queries\": List[str], \"questions\": List[str]}\n\n    Examples:\n        Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"\n        &gt;&gt;&gt; generator = SimpleAggGenerator(database)\n        &gt;&gt;&gt; generator._build_count_cat(\"table_name\", [\"colors\"])\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"SIMPLE-AGG-COUNT\", \"SIMPLE-AGG-COUNT-DISTINCT\"],\n            \"queries\": [\n                'SELECT COUNT(*) FROM \"table_name\"',\n                'SELECT COUNT(DISTINCT\"colors\") FROM \"table_name\"'\n            ],\n            \"questions\": [\n                'Count the records in table \"table_name\"?',\n                'How many different \"colors\" are in table \"table_name\"?'\n            ]\n        }\n        &gt;&gt;&gt; generator._build_count_agg(\"table_name\", [\"numbers\"])\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"SIMPLE-AGG-MAX\", \"SIMPLE-AGG-MIN\", \"SIMPLE-AGG-AVG\"],\n            \"queries\": [\n                'SELECT MAX(\"numbers\") FROM \"table_name\"',\n                'SELECT MIN(\"numbers\") FROM \"table_name\"',\n                'SELECT AVG(\"numbers\") FROM \"table_name\"'\n            ],\n            \"questions\": [\n                'Find the maximum \"numbers\" for the table \"table_name\"',\n                'Find the minimum \"numbers\" for the table \"table_name\"',\n                'Find the average \"numbers\" for the table \"table_name\"'\n            ]\n        }\n    \"\"\"\n    self.empty_sql_generated()\n    _, cat_cols, num_cols = self._sample_cat_num_cols(table_name)\n    self._build_count_cat(table_name, cat_cols)\n    self._build_count_agg(table_name, num_cols)\n    return self.sql_generated\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.WhereGenerator","title":"<code>WhereGenerator</code>","text":"<p>             Bases: <code>AbstractSqlGenerator</code></p> <p>A class for generating WHERE SQL queries and corresponding questions based on a database table.</p> <p>Attributes:</p> Name Type Description <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> <code>sql_generated</code> <code>dict</code> <p>A dictionary containing generated SQL tags, queries, questions, and results. Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str], \"results\": list[pd.DataFrame]}</p> Source code in <code>qatch/sql_generator/where_generator.py</code> <pre><code>class WhereGenerator(AbstractSqlGenerator):\n    \"\"\"\n    A class for generating WHERE SQL queries and corresponding questions based on a database table.\n\n    Attributes:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        sql_generated (dict): A dictionary containing generated SQL tags, queries, questions, and results.\n            Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str], \"results\": list[pd.DataFrame]}\n    \"\"\"\n\n    def __int__(self, database: SingleDatabase, seed=2023):\n        \"\"\"\n        Initializes the GroupBy object.\n\n        Args:\n            database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n            seed (int): The seed to use for the random number generator.\n        \"\"\"\n        super().__init__(database, seed)\n\n    def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n        \"\"\"\n        Generates WHERE SQL queries and corresponding questions for both categorical and numerical columns.\n\n        Args:\n            table_name (str): The name of the table in the database.\n\n        Returns:\n            dict: A dictionary containing generated SQL tags, queries, questions, and results.\n                  Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n\n        Examples:\n            Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"\n            &gt;&gt;&gt; sample_df = pd.DataFrame({\"colors\": [\"green\", \"blue\", \"blue\", \"blue\", \"blue\"], \"numbers\": [1, 2, 3, 4, 5]})\n            &gt;&gt;&gt; generator = WhereGenerator(database)\n            &gt;&gt;&gt; generator._generate_where_categorical(\"table_name\", [\"colors\"], sample_df)\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": [\"WHERE-CAT-MOST-FREQUENT\", \"WHERE-CAT-LEAST-FREQUENT\",\n                            'WHERE-CAT-MOST-FREQUENT', 'WHERE-CAT-LEAST-FREQUENT',\n                            \"WHERE-NOT-MOST-FREQUENT\", \"WHERE-NOT-LEAST-FREQUENT\"],\n                \"queries\": [\n                    'SELECT * FROM \"table_name\" WHERE \"colors\" == \"blue\"',\n                    'SELECT * FROM \"table_name\" WHERE \"colors\" == \"green\"',\n                    'SELECT * FROM \"table_name\" WHERE \"colors\" != \"blue\"',\n                    'SELECT * FROM \"table_name\" WHERE \"colors\" != \"green\"',\n                    'SELECT * FROM \"table_name\" WHERE NOT \"colors\" == \"blue\"',\n                    'SELECT * FROM \"table_name\" WHERE NOT \"colors\" == \"green\"',\n                ],\n                \"questions\": [\n                    'Show the data of the table \"table_name\" where \"colors\" is equal to blue',\n                    'Show the data of the table \"table_name\" where \"colors\" is equal to green',\n                    'Show the data of the table \"table_name\" where \"colors\" is different from blue',\n                    'Show the data of the table \"table_name\" where \"colors\" is different from green',\n                    'Show the data of the table \"table_name\" where \"colors\" is not equal to blue',\n                    'Show the data of the table \"table_name\" where \"colors\" is not equal to green',\n                ]\n            }\n            &gt;&gt;&gt; generator._generate_where_numerical(\"table_name\", [\"numbers\"], sample_df)\n            &gt;&gt;&gt; generator.sql_generated\n            {\n                \"sql_tags\": ['WHERE-NUM-MAX-VALUES-EMPTY', 'WHERE-NUM-MAX-VALUES',\n                            'WHERE-NUM-MIN-VALUES', 'WHERE-NUM-MIN-VALUES-EMPTY',\n                            'WHERE-NUM-MEAN-VALUES', 'WHERE-NUM-MEAN-VALUES'],\n                \"queries\": ['SELECT * FROM \"table_name\" WHERE \"numbers\" &gt; \"5\"',\n                            'SELECT * FROM \"table_name\" WHERE \"numbers\" &lt; \"5\"',\n                            'SELECT * FROM \"table_name\" WHERE \"numbers\" &gt; \"1\"',\n                            'SELECT * FROM \"table_name\" WHERE \"numbers\" &lt; \"1\"',\n                            'SELECT * FROM \"table_name\" WHERE \"numbers\" &gt; \"3.0\"'\n                            'SELECT * FROM \"table_name\" WHERE \"numbers\" &lt; \"3.0\"'],\n                \"question\": ['Show the data of the table \"table_name\" where \"numbers\" is greater than 5',\n                            'Show the data of the table \"table_name\" where \"numbers\" is less than 5',\n                            'Show the data of the table \"table_name\" where \"numbers\" is greater than 1',\n                            'Show the data of the table \"table_name\" where \"numbers\" is less than 1',\n                            'Show the data of the table \"table_name\" where \"numbers\" is greater than 3.0',\n                            'Show the data of the table \"table_name\" where \"numbers\" is less than 3.0'],\n            }\n        \"\"\"\n        self.empty_sql_generated()\n        df, cat_cols, num_cols = self._sample_cat_num_cols(table_name)\n        self._generate_where_categorical(table_name, cat_cols, df)\n        self._generate_where_numerical(table_name, num_cols, df)\n        return self.sql_generated\n\n    def _generate_where_categorical(self, table_name: str, cat_cols: list, df: pd.DataFrame):\n        \"\"\"\n        Generates WHERE SQL queries and questions for categorical columns.\n        Generates test for both most frequent and least frequent values.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            cat_cols (list): List of categorical columns.\n            df (pd.DataFrame): The DataFrame containing the data.\n        \"\"\"\n        if len(cat_cols) == 0:\n            # no categorical attributes present\n            return\n        most_frequent_elements = [self._get_most_frequent_or_max_value(df[col].values) for col in cat_cols]\n        least_frequent_elements = [self._get_least_frequent_or_min_value(df[col].values) for col in cat_cols]\n        for col, most_freq, least_freq in zip(cat_cols, most_frequent_elements, least_frequent_elements):\n            queries = [\n                f\"\"\"SELECT * FROM \"{table_name}\" WHERE \"{col}\" == '{most_freq}'\"\"\",\n                f\"\"\"SELECT * FROM \"{table_name}\" WHERE \"{col}\" == '{least_freq}'\"\"\",\n                f\"\"\"SELECT * FROM \"{table_name}\" WHERE \"{col}\" != '{most_freq}'\"\"\",\n                f\"\"\"SELECT * FROM \"{table_name}\" WHERE \"{col}\" != '{least_freq}'\"\"\",\n                f\"\"\"SELECT * FROM \"{table_name}\" WHERE NOT \"{col}\" == '{most_freq}'\"\"\",\n                f\"\"\"SELECT * FROM \"{table_name}\" WHERE NOT \"{col}\" == '{least_freq}'\"\"\",\n            ]\n\n            questions = [\n                f'Show the data of the table \"{table_name}\" where \"{col}\" is equal to {most_freq}',\n                f'Show the data of the table \"{table_name}\" where \"{col}\" is equal to {least_freq}',\n                f'Show the data of the table \"{table_name}\" where \"{col}\" is different from {most_freq}',\n                f'Show the data of the table \"{table_name}\" where \"{col}\" is different from {least_freq}',\n                f'Show the data of the table \"{table_name}\" where \"{col}\" is not equal to {most_freq}',\n                f'Show the data of the table \"{table_name}\" where \"{col}\" is not equal to {least_freq}',\n            ]\n\n            sql_tags = ['WHERE-CAT-MOST-FREQUENT', 'WHERE-CAT-LEAST-FREQUENT',\n                        'WHERE-CAT-MOST-FREQUENT', 'WHERE-CAT-LEAST-FREQUENT',\n                        'WHERE-NOT-MOST-FREQUENT', 'WHERE-NOT-LEAST-FREQUENT']\n            self.append_sql_generated(sql_tags, queries, questions)\n\n    def _generate_where_numerical(self, table_name: str, num_cols: list, df: pd.DataFrame):\n        \"\"\"\n        Generates WHERE SQL queries and questions for numerical columns.\n        Generates test for max, min, and mean values.\n\n        Args:\n            table_name (str): The name of the table in the database.\n            num_cols (list): List of numerical columns.\n            df (pd.DataFrame): The DataFrame containing the data.\n        \"\"\"\n\n        def _generate_given_value(number, n_col):\n            queries_n = [\n                f'SELECT * FROM \"{table_name}\" WHERE \"{n_col}\" &gt; \"{number}\"',\n                f'SELECT * FROM \"{table_name}\" WHERE \"{n_col}\" &lt; \"{number}\"',\n            ]\n            questions_n = [\n                f'Show the data of the table \"{table_name}\" where \"{n_col}\" is greater than {number}',\n                f'Show the data of the table \"{table_name}\" where \"{n_col}\" is less than {number}',\n            ]\n            return queries_n, questions_n\n\n        if len(num_cols) == 0:\n            return\n        max_elements = [self._get_most_frequent_or_max_value(df[col].values)\n                        for col in num_cols]\n        min_elements = [self._get_least_frequent_or_min_value(df[col].values)\n                        for col in num_cols]\n        mean_values = [self._get_median_value(df[col].values) for col in num_cols]\n        for col, max_value, min_value, mean_value in zip(num_cols, max_elements,\n                                                         min_elements, mean_values):\n            queries, questions = _generate_given_value(max_value, col)\n            sql_tags = ['WHERE-NUM-MAX-VALUES-EMPTY', 'WHERE-NUM-MAX-VALUES']\n            self.append_sql_generated(sql_tags, queries, questions)\n\n            queries, questions = _generate_given_value(min_value, col)\n            sql_tags = ['WHERE-NUM-MIN-VALUES', 'WHERE-NUM-MIN-VALUES-EMPTY']\n            self.append_sql_generated(sql_tags, queries, questions)\n\n            queries, questions = _generate_given_value(mean_value, col)\n            sql_tags = ['WHERE-NUM-MEAN-VALUES'] * len(queries)\n            self.append_sql_generated(sql_tags, queries, questions)\n\n    @staticmethod\n    def _get_most_frequent_or_max_value(values: np.array):\n        \"\"\"\n        Returns the most frequent value if the input is categorical, or the maximum value if numerical.\n        Null values are not considered in the calculation.\n\n        Args:\n            values (np.array): Array of values, either categorical or numerical.\n\n        Returns:\n            Union[None, Any]: Most frequent value if categorical, max value if numerical, or None if input is empty.\n        \"\"\"\n        if len(values) == 0:\n            return None\n        values = values[~pd.isna(values)]\n        # update the dtype after removing the null values\n        values = np.array(values.tolist())\n        if np.issubdtype(values.dtype, np.number):\n            return np.max(values)\n        else:\n            unique_values, counts = np.unique(values, return_counts=True)\n            index_of_max_count = np.argmax(counts)\n            most_frequent_value = unique_values[index_of_max_count]\n            return most_frequent_value.replace('\"', '').replace(\"'\", '').strip()\n\n    @staticmethod\n    def _get_least_frequent_or_min_value(values):\n        \"\"\"\n        Returns the least frequent value if the input is categorical, or the minimum value if numerical.\n        Null values are not considered in the calculation.\n\n        Args:\n            values (np.array): Array of values, either categorical or numerical.\n\n        Returns:\n            Union[None, Any]: Least frequent value if categorical, min value if numerical, or None if input is empty.\n        \"\"\"\n        if len(values) == 0:\n            return None\n        values = values[~pd.isna(values)]\n        # update the dtype after removing the null values\n        values = np.array(values.tolist())\n        if np.issubdtype(values.dtype, np.number):\n            return np.min(values)\n        else:\n            unique_values, counts = np.unique(values, return_counts=True)\n            index_of_min_count = np.argmin(counts)\n            lest_frequent_value = unique_values[index_of_min_count]\n            return lest_frequent_value.replace('\"', '').replace(\"'\", '').strip()\n\n    @staticmethod\n    def _get_median_value(values):\n        \"\"\"\n        Returns the meadin value if the input is numerical. Null values are not considered in the calculation.\n\n        Args:\n            values (np.array): Array of numerical values.\n\n        Returns:\n            Union[None, float]: Mean value of the input array, or None if input is empty or non-numerical.\n        \"\"\"\n        if len(values) == 0:\n            return None\n        values = values[~pd.isna(values)]\n        if np.issubdtype(values.dtype, np.number):\n            return np.mean(values)\n        else:\n            return None\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.WhereGenerator.__int__","title":"<code>__int__(database, seed=2023)</code>","text":"<p>Initializes the GroupBy object.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>SingleDatabase</code> <p>The SingleDatabase object representing the database to generate queries from.</p> required <code>seed</code> <code>int</code> <p>The seed to use for the random number generator.</p> <code>2023</code> Source code in <code>qatch/sql_generator/where_generator.py</code> <pre><code>def __int__(self, database: SingleDatabase, seed=2023):\n    \"\"\"\n    Initializes the GroupBy object.\n\n    Args:\n        database (SingleDatabase): The SingleDatabase object representing the database to generate queries from.\n        seed (int): The seed to use for the random number generator.\n    \"\"\"\n    super().__init__(database, seed)\n</code></pre>"},{"location":"sql_generator/#qatch.sql_generator.WhereGenerator.sql_generate","title":"<code>sql_generate(table_name)</code>","text":"<p>Generates WHERE SQL queries and corresponding questions for both categorical and numerical columns.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table in the database.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, list]</code> <p>A dictionary containing generated SQL tags, queries, questions, and results.   Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}</p> <p>Examples:</p> <p>Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"</p> <pre><code>&gt;&gt;&gt; sample_df = pd.DataFrame({\"colors\": [\"green\", \"blue\", \"blue\", \"blue\", \"blue\"], \"numbers\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; generator = WhereGenerator(database)\n&gt;&gt;&gt; generator._generate_where_categorical(\"table_name\", [\"colors\"], sample_df)\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": [\"WHERE-CAT-MOST-FREQUENT\", \"WHERE-CAT-LEAST-FREQUENT\",\n                'WHERE-CAT-MOST-FREQUENT', 'WHERE-CAT-LEAST-FREQUENT',\n                \"WHERE-NOT-MOST-FREQUENT\", \"WHERE-NOT-LEAST-FREQUENT\"],\n    \"queries\": [\n        'SELECT * FROM \"table_name\" WHERE \"colors\" == \"blue\"',\n        'SELECT * FROM \"table_name\" WHERE \"colors\" == \"green\"',\n        'SELECT * FROM \"table_name\" WHERE \"colors\" != \"blue\"',\n        'SELECT * FROM \"table_name\" WHERE \"colors\" != \"green\"',\n        'SELECT * FROM \"table_name\" WHERE NOT \"colors\" == \"blue\"',\n        'SELECT * FROM \"table_name\" WHERE NOT \"colors\" == \"green\"',\n    ],\n    \"questions\": [\n        'Show the data of the table \"table_name\" where \"colors\" is equal to blue',\n        'Show the data of the table \"table_name\" where \"colors\" is equal to green',\n        'Show the data of the table \"table_name\" where \"colors\" is different from blue',\n        'Show the data of the table \"table_name\" where \"colors\" is different from green',\n        'Show the data of the table \"table_name\" where \"colors\" is not equal to blue',\n        'Show the data of the table \"table_name\" where \"colors\" is not equal to green',\n    ]\n}\n&gt;&gt;&gt; generator._generate_where_numerical(\"table_name\", [\"numbers\"], sample_df)\n&gt;&gt;&gt; generator.sql_generated\n{\n    \"sql_tags\": ['WHERE-NUM-MAX-VALUES-EMPTY', 'WHERE-NUM-MAX-VALUES',\n                'WHERE-NUM-MIN-VALUES', 'WHERE-NUM-MIN-VALUES-EMPTY',\n                'WHERE-NUM-MEAN-VALUES', 'WHERE-NUM-MEAN-VALUES'],\n    \"queries\": ['SELECT * FROM \"table_name\" WHERE \"numbers\" &gt; \"5\"',\n                'SELECT * FROM \"table_name\" WHERE \"numbers\" &lt; \"5\"',\n                'SELECT * FROM \"table_name\" WHERE \"numbers\" &gt; \"1\"',\n                'SELECT * FROM \"table_name\" WHERE \"numbers\" &lt; \"1\"',\n                'SELECT * FROM \"table_name\" WHERE \"numbers\" &gt; \"3.0\"'\n                'SELECT * FROM \"table_name\" WHERE \"numbers\" &lt; \"3.0\"'],\n    \"question\": ['Show the data of the table \"table_name\" where \"numbers\" is greater than 5',\n                'Show the data of the table \"table_name\" where \"numbers\" is less than 5',\n                'Show the data of the table \"table_name\" where \"numbers\" is greater than 1',\n                'Show the data of the table \"table_name\" where \"numbers\" is less than 1',\n                'Show the data of the table \"table_name\" where \"numbers\" is greater than 3.0',\n                'Show the data of the table \"table_name\" where \"numbers\" is less than 3.0'],\n}\n</code></pre> Source code in <code>qatch/sql_generator/where_generator.py</code> <pre><code>def sql_generate(self, table_name: str) -&gt; dict[str, list]:\n    \"\"\"\n    Generates WHERE SQL queries and corresponding questions for both categorical and numerical columns.\n\n    Args:\n        table_name (str): The name of the table in the database.\n\n    Returns:\n        dict: A dictionary containing generated SQL tags, queries, questions, and results.\n              Format: {\"sql_tags\": list[str], \"queries\": list[str], \"questions\": list[str]}\n\n    Examples:\n        Given a MultipleDatabases object \"database\" with a table \"table_name\" with columns \"colors\" and \"numbers\"\n        &gt;&gt;&gt; sample_df = pd.DataFrame({\"colors\": [\"green\", \"blue\", \"blue\", \"blue\", \"blue\"], \"numbers\": [1, 2, 3, 4, 5]})\n        &gt;&gt;&gt; generator = WhereGenerator(database)\n        &gt;&gt;&gt; generator._generate_where_categorical(\"table_name\", [\"colors\"], sample_df)\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": [\"WHERE-CAT-MOST-FREQUENT\", \"WHERE-CAT-LEAST-FREQUENT\",\n                        'WHERE-CAT-MOST-FREQUENT', 'WHERE-CAT-LEAST-FREQUENT',\n                        \"WHERE-NOT-MOST-FREQUENT\", \"WHERE-NOT-LEAST-FREQUENT\"],\n            \"queries\": [\n                'SELECT * FROM \"table_name\" WHERE \"colors\" == \"blue\"',\n                'SELECT * FROM \"table_name\" WHERE \"colors\" == \"green\"',\n                'SELECT * FROM \"table_name\" WHERE \"colors\" != \"blue\"',\n                'SELECT * FROM \"table_name\" WHERE \"colors\" != \"green\"',\n                'SELECT * FROM \"table_name\" WHERE NOT \"colors\" == \"blue\"',\n                'SELECT * FROM \"table_name\" WHERE NOT \"colors\" == \"green\"',\n            ],\n            \"questions\": [\n                'Show the data of the table \"table_name\" where \"colors\" is equal to blue',\n                'Show the data of the table \"table_name\" where \"colors\" is equal to green',\n                'Show the data of the table \"table_name\" where \"colors\" is different from blue',\n                'Show the data of the table \"table_name\" where \"colors\" is different from green',\n                'Show the data of the table \"table_name\" where \"colors\" is not equal to blue',\n                'Show the data of the table \"table_name\" where \"colors\" is not equal to green',\n            ]\n        }\n        &gt;&gt;&gt; generator._generate_where_numerical(\"table_name\", [\"numbers\"], sample_df)\n        &gt;&gt;&gt; generator.sql_generated\n        {\n            \"sql_tags\": ['WHERE-NUM-MAX-VALUES-EMPTY', 'WHERE-NUM-MAX-VALUES',\n                        'WHERE-NUM-MIN-VALUES', 'WHERE-NUM-MIN-VALUES-EMPTY',\n                        'WHERE-NUM-MEAN-VALUES', 'WHERE-NUM-MEAN-VALUES'],\n            \"queries\": ['SELECT * FROM \"table_name\" WHERE \"numbers\" &gt; \"5\"',\n                        'SELECT * FROM \"table_name\" WHERE \"numbers\" &lt; \"5\"',\n                        'SELECT * FROM \"table_name\" WHERE \"numbers\" &gt; \"1\"',\n                        'SELECT * FROM \"table_name\" WHERE \"numbers\" &lt; \"1\"',\n                        'SELECT * FROM \"table_name\" WHERE \"numbers\" &gt; \"3.0\"'\n                        'SELECT * FROM \"table_name\" WHERE \"numbers\" &lt; \"3.0\"'],\n            \"question\": ['Show the data of the table \"table_name\" where \"numbers\" is greater than 5',\n                        'Show the data of the table \"table_name\" where \"numbers\" is less than 5',\n                        'Show the data of the table \"table_name\" where \"numbers\" is greater than 1',\n                        'Show the data of the table \"table_name\" where \"numbers\" is less than 1',\n                        'Show the data of the table \"table_name\" where \"numbers\" is greater than 3.0',\n                        'Show the data of the table \"table_name\" where \"numbers\" is less than 3.0'],\n        }\n    \"\"\"\n    self.empty_sql_generated()\n    df, cat_cols, num_cols = self._sample_cat_num_cols(table_name)\n    self._generate_where_categorical(table_name, cat_cols, df)\n    self._generate_where_numerical(table_name, num_cols, df)\n    return self.sql_generated\n</code></pre>"}]}